
KuartisHomework.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803c00  00803c00  000014d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001460  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  00803c00  00803c00  000014d4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000014d4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001504  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  00001540  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034c3  00000000  00000000  00001648  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002328  00000000  00000000  00004b0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fe8  00000000  00000000  00006e33  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000029c  00000000  00000000  00007e1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ae5  00000000  00000000  000080b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002e9  00000000  00000000  00009b9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f8  00000000  00000000  00009e86  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__ctors_end>
       4:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
       8:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
       c:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__vector_3>
      10:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      14:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      18:	0c 94 cf 06 	jmp	0xd9e	; 0xd9e <__vector_6>
      1c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      20:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      24:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      28:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      2c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      30:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      34:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      38:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      3c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      40:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      44:	0c 94 c2 09 	jmp	0x1384	; 0x1384 <__vector_17>
      48:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      4c:	0c 94 b8 09 	jmp	0x1370	; 0x1370 <__vector_19>
      50:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      54:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      58:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      5c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      60:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      64:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      68:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      6c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      70:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      74:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      78:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      7c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      80:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      84:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      88:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      8c:	0c 94 8d 00 	jmp	0x11a	; 0x11a <__bad_interrupt>
      90:	5d c0       	rjmp	.+186    	; 0x14c <Buzzer+0x30>
      92:	9c c0       	rjmp	.+312    	; 0x1cc <Buzzer+0xb0>
      94:	db c0       	rjmp	.+438    	; 0x24c <Buzzer+0x130>
      96:	ea c0       	rjmp	.+468    	; 0x26c <Buzzer+0x150>
      98:	01 c1       	rjmp	.+514    	; 0x29c <Buzzer+0x180>
      9a:	18 c1       	rjmp	.+560    	; 0x2cc <Buzzer+0x1b0>
      9c:	2e c1       	rjmp	.+604    	; 0x2fa <Buzzer+0x1de>
      9e:	3d c1       	rjmp	.+634    	; 0x31a <Buzzer+0x1fe>
      a0:	5f c1       	rjmp	.+702    	; 0x360 <AdjustBrightness+0x18>
      a2:	64 c1       	rjmp	.+712    	; 0x36c <AdjustBrightness+0x24>
      a4:	69 c1       	rjmp	.+722    	; 0x378 <AdjustBrightness+0x30>
      a6:	6e c1       	rjmp	.+732    	; 0x384 <AdjustBrightness+0x3c>
      a8:	73 c1       	rjmp	.+742    	; 0x390 <AdjustBrightness+0x48>
      aa:	78 c1       	rjmp	.+752    	; 0x39c <AdjustBrightness+0x54>
      ac:	7d c1       	rjmp	.+762    	; 0x3a8 <AdjustBrightness+0x60>
      ae:	82 c1       	rjmp	.+772    	; 0x3b4 <AdjustBrightness+0x6c>
      b0:	87 c1       	rjmp	.+782    	; 0x3c0 <AdjustBrightness+0x78>
      b2:	8c c1       	rjmp	.+792    	; 0x3cc <AdjustBrightness+0x84>
      b4:	a2 c1       	rjmp	.+836    	; 0x3fa <incrementLight+0x16>
      b6:	a5 c1       	rjmp	.+842    	; 0x402 <__DATA_REGION_LENGTH__+0x2>
      b8:	a8 c1       	rjmp	.+848    	; 0x40a <__DATA_REGION_LENGTH__+0xa>
      ba:	ab c1       	rjmp	.+854    	; 0x412 <__DATA_REGION_LENGTH__+0x12>
      bc:	ae c1       	rjmp	.+860    	; 0x41a <__DATA_REGION_LENGTH__+0x1a>
      be:	b1 c1       	rjmp	.+866    	; 0x422 <__DATA_REGION_LENGTH__+0x22>
      c0:	b4 c1       	rjmp	.+872    	; 0x42a <__DATA_REGION_LENGTH__+0x2a>
      c2:	b7 c1       	rjmp	.+878    	; 0x432 <__DATA_REGION_LENGTH__+0x32>
      c4:	ba c1       	rjmp	.+884    	; 0x43a <__DATA_REGION_LENGTH__+0x3a>
      c6:	c9 c1       	rjmp	.+914    	; 0x45a <decrementLight+0x18>
      c8:	cb c1       	rjmp	.+918    	; 0x460 <decrementLight+0x1e>
      ca:	ce c1       	rjmp	.+924    	; 0x468 <decrementLight+0x26>
      cc:	d1 c1       	rjmp	.+930    	; 0x470 <decrementLight+0x2e>
      ce:	d4 c1       	rjmp	.+936    	; 0x478 <decrementLight+0x36>
      d0:	d7 c1       	rjmp	.+942    	; 0x480 <decrementLight+0x3e>
      d2:	da c1       	rjmp	.+948    	; 0x488 <decrementLight+0x46>
      d4:	dd c1       	rjmp	.+954    	; 0x490 <decrementLight+0x4e>
      d6:	e0 c1       	rjmp	.+960    	; 0x498 <decrementLight+0x56>
      d8:	94 c2       	rjmp	.+1320   	; 0x602 <setState+0x18>
      da:	a1 c2       	rjmp	.+1346   	; 0x61e <setState+0x34>
      dc:	af c2       	rjmp	.+1374   	; 0x63c <setState+0x52>
      de:	bd c2       	rjmp	.+1402   	; 0x65a <setState+0x70>
      e0:	d3 c2       	rjmp	.+1446   	; 0x688 <setState+0x9e>
      e2:	df c2       	rjmp	.+1470   	; 0x6a2 <setState+0xb8>
      e4:	e0 c2       	rjmp	.+1472   	; 0x6a6 <setState+0xbc>
      e6:	ce c5       	rjmp	.+2972   	; 0xc84 <EEPROM_write+0x32>
      e8:	d1 c5       	rjmp	.+2978   	; 0xc8c <EEPROM_write+0x3a>
      ea:	d4 c5       	rjmp	.+2984   	; 0xc94 <EEPROM_write+0x42>
      ec:	d7 c5       	rjmp	.+2990   	; 0xc9c <EEPROM_write+0x4a>
      ee:	da c5       	rjmp	.+2996   	; 0xca4 <EEPROM_write+0x52>
      f0:	dd c5       	rjmp	.+3002   	; 0xcac <EEPROM_write+0x5a>
      f2:	e0 c5       	rjmp	.+3008   	; 0xcb4 <EEPROM_write+0x62>
      f4:	e3 c5       	rjmp	.+3014   	; 0xcbc <EEPROM_write+0x6a>
      f6:	e6 c5       	rjmp	.+3020   	; 0xcc4 <EEPROM_write+0x72>
      f8:	e9 c5       	rjmp	.+3026   	; 0xccc <EEPROM_write+0x7a>

000000fa <__ctors_end>:
      fa:	11 24       	eor	r1, r1
      fc:	1f be       	out	0x3f, r1	; 63
      fe:	cf ef       	ldi	r28, 0xFF	; 255
     100:	cd bf       	out	0x3d, r28	; 61
     102:	df e3       	ldi	r29, 0x3F	; 63
     104:	de bf       	out	0x3e, r29	; 62

00000106 <__do_clear_bss>:
     106:	2c e3       	ldi	r18, 0x3C	; 60
     108:	a0 e0       	ldi	r26, 0x00	; 0
     10a:	bc e3       	ldi	r27, 0x3C	; 60
     10c:	01 c0       	rjmp	.+2      	; 0x110 <.do_clear_bss_start>

0000010e <.do_clear_bss_loop>:
     10e:	1d 92       	st	X+, r1

00000110 <.do_clear_bss_start>:
     110:	af 34       	cpi	r26, 0x4F	; 79
     112:	b2 07       	cpc	r27, r18
     114:	e1 f7       	brne	.-8      	; 0x10e <.do_clear_bss_loop>
     116:	40 d9       	rcall	.-3456   	; 0xfffff398 <__eeprom_end+0xff7ef398>
     118:	a1 c9       	rjmp	.-3262   	; 0xfffff45c <__eeprom_end+0xff7ef45c>

0000011a <__bad_interrupt>:
     11a:	72 cf       	rjmp	.-284    	; 0x0 <__vectors>

0000011c <Buzzer>:
/************************************************************************/
/* Buzzer function gives different sounds according to the current state. Every button gives different sound.
They also give different sounds according to the current mode.                                                                     */
/************************************************************************/
void Buzzer(){
	BuzzerFlag=1;
     11c:	81 e0       	ldi	r24, 0x01	; 1
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	a0 e0       	ldi	r26, 0x00	; 0
     122:	b0 e0       	ldi	r27, 0x00	; 0
     124:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerFlag>
     128:	90 93 41 3c 	sts	0x3C41, r25	; 0x803c41 <BuzzerFlag+0x1>
     12c:	a0 93 42 3c 	sts	0x3C42, r26	; 0x803c42 <BuzzerFlag+0x2>
     130:	b0 93 43 3c 	sts	0x3C43, r27	; 0x803c43 <BuzzerFlag+0x3>
	switch(BuzzerState.currentState){
     134:	e0 91 4e 3c 	lds	r30, 0x3C4E	; 0x803c4e <BuzzerState>
     138:	8e 2f       	mov	r24, r30
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	88 30       	cpi	r24, 0x08	; 8
     13e:	91 05       	cpc	r25, r1
     140:	08 f0       	brcs	.+2      	; 0x144 <Buzzer+0x28>
     142:	01 c1       	rjmp	.+514    	; 0x346 <Buzzer+0x22a>
     144:	fc 01       	movw	r30, r24
     146:	e8 5b       	subi	r30, 0xB8	; 184
     148:	ff 4f       	sbci	r31, 0xFF	; 255
     14a:	09 94       	ijmp
		case(POWER_ON_SOUND):
			if(BuzzerCounter%2==0&&Pitch_flag==1){
     14c:	80 91 3c 3c 	lds	r24, 0x3C3C	; 0x803c3c <BuzzerCounter>
     150:	90 91 3d 3c 	lds	r25, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     154:	a0 91 3e 3c 	lds	r26, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     158:	b0 91 3f 3c 	lds	r27, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     15c:	80 fd       	sbrc	r24, 0
     15e:	11 c0       	rjmp	.+34     	; 0x182 <Buzzer+0x66>
     160:	80 91 38 3c 	lds	r24, 0x3C38	; 0x803c38 <Pitch_flag>
     164:	90 91 39 3c 	lds	r25, 0x3C39	; 0x803c39 <Pitch_flag+0x1>
     168:	a0 91 3a 3c 	lds	r26, 0x3C3A	; 0x803c3a <Pitch_flag+0x2>
     16c:	b0 91 3b 3c 	lds	r27, 0x3C3B	; 0x803c3b <Pitch_flag+0x3>
     170:	01 97       	sbiw	r24, 0x01	; 1
     172:	a1 05       	cpc	r26, r1
     174:	b1 05       	cpc	r27, r1
     176:	29 f4       	brne	.+10     	; 0x182 <Buzzer+0x66>
				PORTD.OUT ^= (1<<BUZZER);
     178:	e0 e6       	ldi	r30, 0x60	; 96
     17a:	f4 e0       	ldi	r31, 0x04	; 4
     17c:	84 81       	ldd	r24, Z+4	; 0x04
     17e:	80 58       	subi	r24, 0x80	; 128
     180:	84 83       	std	Z+4, r24	; 0x04
			}
			if(BuzzerCounter%10==0&&Pitch_flag==0){
     182:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     186:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     18a:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     18e:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     192:	2a e0       	ldi	r18, 0x0A	; 10
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	40 e0       	ldi	r20, 0x00	; 0
     198:	50 e0       	ldi	r21, 0x00	; 0
     19a:	00 d9       	rcall	.-3584   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     19c:	67 2b       	or	r22, r23
     19e:	68 2b       	or	r22, r24
     1a0:	69 2b       	or	r22, r25
     1a2:	09 f0       	breq	.+2      	; 0x1a6 <Buzzer+0x8a>
     1a4:	d0 c0       	rjmp	.+416    	; 0x346 <Buzzer+0x22a>
     1a6:	80 91 38 3c 	lds	r24, 0x3C38	; 0x803c38 <Pitch_flag>
     1aa:	90 91 39 3c 	lds	r25, 0x3C39	; 0x803c39 <Pitch_flag+0x1>
     1ae:	a0 91 3a 3c 	lds	r26, 0x3C3A	; 0x803c3a <Pitch_flag+0x2>
     1b2:	b0 91 3b 3c 	lds	r27, 0x3C3B	; 0x803c3b <Pitch_flag+0x3>
     1b6:	89 2b       	or	r24, r25
     1b8:	8a 2b       	or	r24, r26
     1ba:	8b 2b       	or	r24, r27
     1bc:	09 f0       	breq	.+2      	; 0x1c0 <Buzzer+0xa4>
     1be:	c3 c0       	rjmp	.+390    	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     1c0:	e0 e6       	ldi	r30, 0x60	; 96
     1c2:	f4 e0       	ldi	r31, 0x04	; 4
     1c4:	84 81       	ldd	r24, Z+4	; 0x04
     1c6:	80 58       	subi	r24, 0x80	; 128
     1c8:	84 83       	std	Z+4, r24	; 0x04
     1ca:	08 95       	ret
			}
			
						
			break;
		case(POWER_OFF_SOUND):
			if(BuzzerCounter%2==0&&Pitch_flag==0){
     1cc:	80 91 3c 3c 	lds	r24, 0x3C3C	; 0x803c3c <BuzzerCounter>
     1d0:	90 91 3d 3c 	lds	r25, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     1d4:	a0 91 3e 3c 	lds	r26, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     1d8:	b0 91 3f 3c 	lds	r27, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     1dc:	80 fd       	sbrc	r24, 0
     1de:	11 c0       	rjmp	.+34     	; 0x202 <Buzzer+0xe6>
     1e0:	80 91 38 3c 	lds	r24, 0x3C38	; 0x803c38 <Pitch_flag>
     1e4:	90 91 39 3c 	lds	r25, 0x3C39	; 0x803c39 <Pitch_flag+0x1>
     1e8:	a0 91 3a 3c 	lds	r26, 0x3C3A	; 0x803c3a <Pitch_flag+0x2>
     1ec:	b0 91 3b 3c 	lds	r27, 0x3C3B	; 0x803c3b <Pitch_flag+0x3>
     1f0:	89 2b       	or	r24, r25
     1f2:	8a 2b       	or	r24, r26
     1f4:	8b 2b       	or	r24, r27
     1f6:	29 f4       	brne	.+10     	; 0x202 <Buzzer+0xe6>
				PORTD.OUT ^= (1<<BUZZER);
     1f8:	e0 e6       	ldi	r30, 0x60	; 96
     1fa:	f4 e0       	ldi	r31, 0x04	; 4
     1fc:	84 81       	ldd	r24, Z+4	; 0x04
     1fe:	80 58       	subi	r24, 0x80	; 128
     200:	84 83       	std	Z+4, r24	; 0x04
			}
			if(BuzzerCounter%10==0&&Pitch_flag==1){
     202:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     206:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     20a:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     20e:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     212:	2a e0       	ldi	r18, 0x0A	; 10
     214:	30 e0       	ldi	r19, 0x00	; 0
     216:	40 e0       	ldi	r20, 0x00	; 0
     218:	50 e0       	ldi	r21, 0x00	; 0
     21a:	c0 d8       	rcall	.-3712   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     21c:	67 2b       	or	r22, r23
     21e:	68 2b       	or	r22, r24
     220:	69 2b       	or	r22, r25
     222:	09 f0       	breq	.+2      	; 0x226 <Buzzer+0x10a>
     224:	90 c0       	rjmp	.+288    	; 0x346 <Buzzer+0x22a>
     226:	80 91 38 3c 	lds	r24, 0x3C38	; 0x803c38 <Pitch_flag>
     22a:	90 91 39 3c 	lds	r25, 0x3C39	; 0x803c39 <Pitch_flag+0x1>
     22e:	a0 91 3a 3c 	lds	r26, 0x3C3A	; 0x803c3a <Pitch_flag+0x2>
     232:	b0 91 3b 3c 	lds	r27, 0x3C3B	; 0x803c3b <Pitch_flag+0x3>
     236:	01 97       	sbiw	r24, 0x01	; 1
     238:	a1 05       	cpc	r26, r1
     23a:	b1 05       	cpc	r27, r1
     23c:	09 f0       	breq	.+2      	; 0x240 <Buzzer+0x124>
     23e:	83 c0       	rjmp	.+262    	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     240:	e0 e6       	ldi	r30, 0x60	; 96
     242:	f4 e0       	ldi	r31, 0x04	; 4
     244:	84 81       	ldd	r24, Z+4	; 0x04
     246:	80 58       	subi	r24, 0x80	; 128
     248:	84 83       	std	Z+4, r24	; 0x04
     24a:	08 95       	ret
			}
		break;
		case(INC_SOUND):
			if(BuzzerCounter%2==0){
     24c:	80 91 3c 3c 	lds	r24, 0x3C3C	; 0x803c3c <BuzzerCounter>
     250:	90 91 3d 3c 	lds	r25, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     254:	a0 91 3e 3c 	lds	r26, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     258:	b0 91 3f 3c 	lds	r27, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     25c:	80 fd       	sbrc	r24, 0
     25e:	73 c0       	rjmp	.+230    	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     260:	e0 e6       	ldi	r30, 0x60	; 96
     262:	f4 e0       	ldi	r31, 0x04	; 4
     264:	84 81       	ldd	r24, Z+4	; 0x04
     266:	80 58       	subi	r24, 0x80	; 128
     268:	84 83       	std	Z+4, r24	; 0x04
     26a:	08 95       	ret
			}
			break;
		case(DEC_SOUND):
			if(BuzzerCounter%10==0){
     26c:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     270:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     274:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     278:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     27c:	2a e0       	ldi	r18, 0x0A	; 10
     27e:	30 e0       	ldi	r19, 0x00	; 0
     280:	40 e0       	ldi	r20, 0x00	; 0
     282:	50 e0       	ldi	r21, 0x00	; 0
     284:	8b d8       	rcall	.-3818   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     286:	67 2b       	or	r22, r23
     288:	68 2b       	or	r22, r24
     28a:	69 2b       	or	r22, r25
     28c:	09 f0       	breq	.+2      	; 0x290 <Buzzer+0x174>
     28e:	5b c0       	rjmp	.+182    	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     290:	e0 e6       	ldi	r30, 0x60	; 96
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	84 81       	ldd	r24, Z+4	; 0x04
     296:	80 58       	subi	r24, 0x80	; 128
     298:	84 83       	std	Z+4, r24	; 0x04
     29a:	08 95       	ret
			}
			break;
		case(LIGHT_SOUND):
				if(BuzzerCounter%20==0){
     29c:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     2a0:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     2a4:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     2a8:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     2ac:	24 e1       	ldi	r18, 0x14	; 20
     2ae:	30 e0       	ldi	r19, 0x00	; 0
     2b0:	40 e0       	ldi	r20, 0x00	; 0
     2b2:	50 e0       	ldi	r21, 0x00	; 0
     2b4:	73 d8       	rcall	.-3866   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     2b6:	67 2b       	or	r22, r23
     2b8:	68 2b       	or	r22, r24
     2ba:	69 2b       	or	r22, r25
     2bc:	09 f0       	breq	.+2      	; 0x2c0 <Buzzer+0x1a4>
     2be:	43 c0       	rjmp	.+134    	; 0x346 <Buzzer+0x22a>
					PORTD.OUT ^= (1<<BUZZER);
     2c0:	e0 e6       	ldi	r30, 0x60	; 96
     2c2:	f4 e0       	ldi	r31, 0x04	; 4
     2c4:	84 81       	ldd	r24, Z+4	; 0x04
     2c6:	80 58       	subi	r24, 0x80	; 128
     2c8:	84 83       	std	Z+4, r24	; 0x04
     2ca:	08 95       	ret
				}
			break;
		case(DEV_INIT_SOUND):
			if(BuzzerCounter%10==0){
     2cc:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     2d0:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     2d4:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     2d8:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     2dc:	2a e0       	ldi	r18, 0x0A	; 10
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	40 e0       	ldi	r20, 0x00	; 0
     2e2:	50 e0       	ldi	r21, 0x00	; 0
     2e4:	5b d8       	rcall	.-3914   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     2e6:	67 2b       	or	r22, r23
     2e8:	68 2b       	or	r22, r24
     2ea:	69 2b       	or	r22, r25
     2ec:	61 f5       	brne	.+88     	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     2ee:	e0 e6       	ldi	r30, 0x60	; 96
     2f0:	f4 e0       	ldi	r31, 0x04	; 4
     2f2:	84 81       	ldd	r24, Z+4	; 0x04
     2f4:	80 58       	subi	r24, 0x80	; 128
     2f6:	84 83       	std	Z+4, r24	; 0x04
     2f8:	08 95       	ret
			}
			break;
		case(DEV_MODE_SOUND):
			if(BuzzerCounter%2==0){
     2fa:	80 91 3c 3c 	lds	r24, 0x3C3C	; 0x803c3c <BuzzerCounter>
     2fe:	90 91 3d 3c 	lds	r25, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     302:	a0 91 3e 3c 	lds	r26, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     306:	b0 91 3f 3c 	lds	r27, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     30a:	80 fd       	sbrc	r24, 0
     30c:	1c c0       	rjmp	.+56     	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     30e:	e0 e6       	ldi	r30, 0x60	; 96
     310:	f4 e0       	ldi	r31, 0x04	; 4
     312:	84 81       	ldd	r24, Z+4	; 0x04
     314:	80 58       	subi	r24, 0x80	; 128
     316:	84 83       	std	Z+4, r24	; 0x04
     318:	08 95       	ret
			}
			break;
		case(LIGHT_ADJ_SOUND):
			if(BuzzerCounter%10==0){
     31a:	60 91 3c 3c 	lds	r22, 0x3C3C	; 0x803c3c <BuzzerCounter>
     31e:	70 91 3d 3c 	lds	r23, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
     322:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
     326:	90 91 3f 3c 	lds	r25, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
     32a:	2a e0       	ldi	r18, 0x0A	; 10
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	40 e0       	ldi	r20, 0x00	; 0
     330:	50 e0       	ldi	r21, 0x00	; 0
     332:	34 d8       	rcall	.-3992   	; 0xfffff39c <__eeprom_end+0xff7ef39c>
     334:	67 2b       	or	r22, r23
     336:	68 2b       	or	r22, r24
     338:	69 2b       	or	r22, r25
     33a:	29 f4       	brne	.+10     	; 0x346 <Buzzer+0x22a>
				PORTD.OUT ^= (1<<BUZZER);
     33c:	e0 e6       	ldi	r30, 0x60	; 96
     33e:	f4 e0       	ldi	r31, 0x04	; 4
     340:	84 81       	ldd	r24, Z+4	; 0x04
     342:	80 58       	subi	r24, 0x80	; 128
     344:	84 83       	std	Z+4, r24	; 0x04
     346:	08 95       	ret

00000348 <AdjustBrightness>:
/************************************************************************/
/* This function simulates the current brightness level using 4 LEDs on the hood.
To simulate we are counting to "10" in binary.                                                                  */
/************************************************************************/
void AdjustBrightness(){
	switch(BrightModeState.currentState){
     348:	e0 91 4b 3c 	lds	r30, 0x3C4B	; 0x803c4b <BrightModeState>
     34c:	8e 2f       	mov	r24, r30
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	8a 30       	cpi	r24, 0x0A	; 10
     352:	91 05       	cpc	r25, r1
     354:	08 f0       	brcs	.+2      	; 0x358 <AdjustBrightness+0x10>
     356:	40 c0       	rjmp	.+128    	; 0x3d8 <AdjustBrightness+0x90>
     358:	fc 01       	movw	r30, r24
     35a:	e0 5b       	subi	r30, 0xB0	; 176
     35c:	ff 4f       	sbci	r31, 0xFF	; 255
     35e:	09 94       	ijmp
		case(BRIGHT_ONE):
			PORTA.OUT &= ~(1<<LED_1);
     360:	e0 e0       	ldi	r30, 0x00	; 0
     362:	f4 e0       	ldi	r31, 0x04	; 4
     364:	84 81       	ldd	r24, Z+4	; 0x04
     366:	8e 7f       	andi	r24, 0xFE	; 254
     368:	84 83       	std	Z+4, r24	; 0x04
		break;
     36a:	08 95       	ret
		case(BRIGHT_TWO):
			PORTA.OUT &=  ~(1<<LED_2);
     36c:	e0 e0       	ldi	r30, 0x00	; 0
     36e:	f4 e0       	ldi	r31, 0x04	; 4
     370:	84 81       	ldd	r24, Z+4	; 0x04
     372:	8b 7f       	andi	r24, 0xFB	; 251
     374:	84 83       	std	Z+4, r24	; 0x04
		break;
     376:	08 95       	ret
		case(BRIGHT_THREE):
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2);
     378:	e0 e0       	ldi	r30, 0x00	; 0
     37a:	f4 e0       	ldi	r31, 0x04	; 4
     37c:	84 81       	ldd	r24, Z+4	; 0x04
     37e:	8a 7f       	andi	r24, 0xFA	; 250
     380:	84 83       	std	Z+4, r24	; 0x04
		break;
     382:	08 95       	ret
		case(BRIGHT_FOUR):
			PORTA.OUT &= ~(1<<LED_3) ;
     384:	e0 e0       	ldi	r30, 0x00	; 0
     386:	f4 e0       	ldi	r31, 0x04	; 4
     388:	84 81       	ldd	r24, Z+4	; 0x04
     38a:	8d 7f       	andi	r24, 0xFD	; 253
     38c:	84 83       	std	Z+4, r24	; 0x04
		break;
     38e:	08 95       	ret
		case(BRIGHT_FIVE):
			PORTA.OUT &= ~(1<<LED_3) & ~(1<<LED_1);
     390:	e0 e0       	ldi	r30, 0x00	; 0
     392:	f4 e0       	ldi	r31, 0x04	; 4
     394:	84 81       	ldd	r24, Z+4	; 0x04
     396:	8c 7f       	andi	r24, 0xFC	; 252
     398:	84 83       	std	Z+4, r24	; 0x04
		break;
     39a:	08 95       	ret
		case(BRIGHT_SIX):
			PORTA.OUT &= ~(1<<LED_3) & ~(1<<LED_2);
     39c:	e0 e0       	ldi	r30, 0x00	; 0
     39e:	f4 e0       	ldi	r31, 0x04	; 4
     3a0:	84 81       	ldd	r24, Z+4	; 0x04
     3a2:	89 7f       	andi	r24, 0xF9	; 249
     3a4:	84 83       	std	Z+4, r24	; 0x04
		break;
     3a6:	08 95       	ret
		case(BRIGHT_SEVEN):
			PORTA.OUT &= ~(1<<LED_3) & ~(1<<LED_2) & ~(1<<LED_1);
     3a8:	e0 e0       	ldi	r30, 0x00	; 0
     3aa:	f4 e0       	ldi	r31, 0x04	; 4
     3ac:	84 81       	ldd	r24, Z+4	; 0x04
     3ae:	88 7f       	andi	r24, 0xF8	; 248
     3b0:	84 83       	std	Z+4, r24	; 0x04
		break;
     3b2:	08 95       	ret
		case(BRIGHT_EIGHT):
			PORTA.OUT &= ~(1<<LED_4);
     3b4:	e0 e0       	ldi	r30, 0x00	; 0
     3b6:	f4 e0       	ldi	r31, 0x04	; 4
     3b8:	84 81       	ldd	r24, Z+4	; 0x04
     3ba:	8f 7d       	andi	r24, 0xDF	; 223
     3bc:	84 83       	std	Z+4, r24	; 0x04
		break;
     3be:	08 95       	ret
		case(BRIGHT_NINE):
			PORTA.OUT &= ~(1<<LED_4) & ~(1<<LED_1);
     3c0:	e0 e0       	ldi	r30, 0x00	; 0
     3c2:	f4 e0       	ldi	r31, 0x04	; 4
     3c4:	84 81       	ldd	r24, Z+4	; 0x04
     3c6:	8e 7d       	andi	r24, 0xDE	; 222
     3c8:	84 83       	std	Z+4, r24	; 0x04
		break;
     3ca:	08 95       	ret
		case(BRIGHT_TEN):
			PORTA.OUT &= ~(1<<LED_4) & ~(1<<LED_2);
     3cc:	e0 e0       	ldi	r30, 0x00	; 0
     3ce:	f4 e0       	ldi	r31, 0x04	; 4
     3d0:	84 81       	ldd	r24, Z+4	; 0x04
     3d2:	8b 7d       	andi	r24, 0xDB	; 219
     3d4:	84 83       	std	Z+4, r24	; 0x04
		break;
     3d6:	08 95       	ret
		default:
			PORTA.OUT = 0xFF; // All LEDs OFF
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	80 93 04 04 	sts	0x0404, r24	; 0x800404 <__RODATA_PM_OFFSET__+0x7fc404>
			PORTD.OUT = 0x00; // All MOTORs OFF
     3de:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
     3e2:	08 95       	ret

000003e4 <incrementLight>:
/************************************************************************/
/* This function increases the brightness level by 1. If we are at level 10,
the level increases no more.                                                                     */
/************************************************************************/
void incrementLight(){
	switch(BrightModeState.currentState){
     3e4:	e0 91 4b 3c 	lds	r30, 0x3C4B	; 0x803c4b <BrightModeState>
     3e8:	8e 2f       	mov	r24, r30
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	89 30       	cpi	r24, 0x09	; 9
     3ee:	91 05       	cpc	r25, r1
     3f0:	38 f5       	brcc	.+78     	; 0x440 <__DATA_REGION_LENGTH__+0x40>
     3f2:	fc 01       	movw	r30, r24
     3f4:	e6 5a       	subi	r30, 0xA6	; 166
     3f6:	ff 4f       	sbci	r31, 0xFF	; 255
     3f8:	09 94       	ijmp
		case(BRIGHT_ONE):
			BrightModeState.currentState = BRIGHT_TWO;
     3fa:	81 e0       	ldi	r24, 0x01	; 1
     3fc:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     400:	08 95       	ret
		case(BRIGHT_TWO):
			BrightModeState.currentState = BRIGHT_THREE;
     402:	82 e0       	ldi	r24, 0x02	; 2
     404:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     408:	08 95       	ret
		case(BRIGHT_THREE):
			BrightModeState.currentState = BRIGHT_FOUR;
     40a:	83 e0       	ldi	r24, 0x03	; 3
     40c:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     410:	08 95       	ret
		case(BRIGHT_FOUR):
			BrightModeState.currentState = BRIGHT_FIVE;
     412:	84 e0       	ldi	r24, 0x04	; 4
     414:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     418:	08 95       	ret
		case(BRIGHT_FIVE):
			BrightModeState.currentState = BRIGHT_SIX;
     41a:	85 e0       	ldi	r24, 0x05	; 5
     41c:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     420:	08 95       	ret
		case(BRIGHT_SIX):
			BrightModeState.currentState = BRIGHT_SEVEN;
     422:	86 e0       	ldi	r24, 0x06	; 6
     424:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     428:	08 95       	ret
		case(BRIGHT_SEVEN):
			BrightModeState.currentState = BRIGHT_EIGHT;
     42a:	87 e0       	ldi	r24, 0x07	; 7
     42c:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     430:	08 95       	ret
		case(BRIGHT_EIGHT):
			BrightModeState.currentState = BRIGHT_NINE;
     432:	88 e0       	ldi	r24, 0x08	; 8
     434:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     438:	08 95       	ret
		case(BRIGHT_NINE):
			BrightModeState.currentState = BRIGHT_TEN;
     43a:	89 e0       	ldi	r24, 0x09	; 9
     43c:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
     440:	08 95       	ret

00000442 <decrementLight>:
/************************************************************************/
/* This function decreases the brightness level by 1. If we are at level 1,
the level decreases no more.                                                                     */
/************************************************************************/
void decrementLight(){
	switch(BrightModeState.currentState){
     442:	e0 91 4b 3c 	lds	r30, 0x3C4B	; 0x803c4b <BrightModeState>
     446:	8e 2f       	mov	r24, r30
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	fc 01       	movw	r30, r24
     44c:	31 97       	sbiw	r30, 0x01	; 1
     44e:	e9 30       	cpi	r30, 0x09	; 9
     450:	f1 05       	cpc	r31, r1
     452:	28 f5       	brcc	.+74     	; 0x49e <decrementLight+0x5c>
     454:	ed 59       	subi	r30, 0x9D	; 157
     456:	ff 4f       	sbci	r31, 0xFF	; 255
     458:	09 94       	ijmp
		case(BRIGHT_ONE):
		//Cannot decrement more
		break;
		case(BRIGHT_TWO):
		BrightModeState.currentState = BRIGHT_ONE;
     45a:	10 92 4b 3c 	sts	0x3C4B, r1	; 0x803c4b <BrightModeState>
		break;
     45e:	08 95       	ret
		case(BRIGHT_THREE):
		BrightModeState.currentState = BRIGHT_TWO;
     460:	81 e0       	ldi	r24, 0x01	; 1
     462:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     466:	08 95       	ret
		case(BRIGHT_FOUR):
		BrightModeState.currentState = BRIGHT_THREE;
     468:	82 e0       	ldi	r24, 0x02	; 2
     46a:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     46e:	08 95       	ret
		case(BRIGHT_FIVE):
		BrightModeState.currentState = BRIGHT_FOUR;
     470:	83 e0       	ldi	r24, 0x03	; 3
     472:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     476:	08 95       	ret
		case(BRIGHT_SIX):
		BrightModeState.currentState = BRIGHT_FIVE;
     478:	84 e0       	ldi	r24, 0x04	; 4
     47a:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     47e:	08 95       	ret
		case(BRIGHT_SEVEN):
		BrightModeState.currentState = BRIGHT_SIX;
     480:	85 e0       	ldi	r24, 0x05	; 5
     482:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     486:	08 95       	ret
		case(BRIGHT_EIGHT):
		BrightModeState.currentState = BRIGHT_SEVEN;
     488:	86 e0       	ldi	r24, 0x06	; 6
     48a:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     48e:	08 95       	ret
		case(BRIGHT_NINE):
		BrightModeState.currentState = BRIGHT_EIGHT;
     490:	87 e0       	ldi	r24, 0x07	; 7
     492:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
		break;
     496:	08 95       	ret
		case(BRIGHT_TEN):
		BrightModeState.currentState = BRIGHT_NINE;
     498:	88 e0       	ldi	r24, 0x08	; 8
     49a:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
     49e:	08 95       	ret

000004a0 <VerifyAddress>:
/* First 2 bytes are address decimals. They are "129" and "102" in decimal
We need to verify this decimals, because different remotes can send IR signals also.
This function verifies first two bytes. Returns "1" if the address are true, "0" if false.                                                                   */
/************************************************************************/
bool VerifyAddress(){
	if((command_register & 0xFFFF0000) == ADDRESS_bm)
     4a0:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     4a4:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     4a8:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     4ac:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     4b0:	88 27       	eor	r24, r24
     4b2:	99 27       	eor	r25, r25
     4b4:	00 97       	sbiw	r24, 0x00	; 0
     4b6:	a6 46       	sbci	r26, 0x66	; 102
     4b8:	b1 48       	sbci	r27, 0x81	; 129
     4ba:	11 f4       	brne	.+4      	; 0x4c0 <VerifyAddress+0x20>
	return true;
     4bc:	81 e0       	ldi	r24, 0x01	; 1
     4be:	08 95       	ret
	else return false;
     4c0:	80 e0       	ldi	r24, 0x00	; 0
}
     4c2:	08 95       	ret

000004c4 <GenerateRepeatCode>:
void GenerateRepeatCode(){
	tick_counter=0;
     4c4:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <tick_counter>
     4c8:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <tick_counter+0x1>
     4cc:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <tick_counter+0x2>
     4d0:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <tick_counter+0x3>
	hold_flag=1;
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	80 93 20 3c 	sts	0x3C20, r24	; 0x803c20 <hold_flag>
     4dc:	90 93 21 3c 	sts	0x3C21, r25	; 0x803c21 <hold_flag+0x1>
	if(InputState.currentState==POWER || InputState.currentState==POWER_HOLD){
     4e0:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
     4e4:	82 30       	cpi	r24, 0x02	; 2
     4e6:	20 f4       	brcc	.+8      	; 0x4f0 <GenerateRepeatCode+0x2c>
		InputState.currentState=POWER_HOLD;
     4e8:	81 e0       	ldi	r24, 0x01	; 1
     4ea:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     4ee:	08 95       	ret
		
	}
	else if(InputState.currentState==INCREMENT || InputState.currentState==INCREMENT_HOLD){
     4f0:	9e ef       	ldi	r25, 0xFE	; 254
     4f2:	98 0f       	add	r25, r24
     4f4:	92 30       	cpi	r25, 0x02	; 2
     4f6:	20 f4       	brcc	.+8      	; 0x500 <GenerateRepeatCode+0x3c>
		InputState.currentState=INCREMENT_HOLD;
     4f8:	83 e0       	ldi	r24, 0x03	; 3
     4fa:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     4fe:	08 95       	ret
	}
	else if(InputState.currentState==DECREMENT ||InputState.currentState==DECREMENT_HOLD){
     500:	9c ef       	ldi	r25, 0xFC	; 252
     502:	98 0f       	add	r25, r24
     504:	92 30       	cpi	r25, 0x02	; 2
     506:	20 f4       	brcc	.+8      	; 0x510 <GenerateRepeatCode+0x4c>
		InputState.currentState=DECREMENT_HOLD;
     508:	85 e0       	ldi	r24, 0x05	; 5
     50a:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     50e:	08 95       	ret
	}
	else if(InputState.currentState==LIGHT || InputState.currentState==LIGHT_HOLD){
     510:	86 50       	subi	r24, 0x06	; 6
     512:	82 30       	cpi	r24, 0x02	; 2
     514:	18 f4       	brcc	.+6      	; 0x51c <GenerateRepeatCode+0x58>
			InputState.currentState=LIGHT_HOLD;
     516:	87 e0       	ldi	r24, 0x07	; 7
     518:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     51c:	08 95       	ret

0000051e <disableIR_ISR>:

/************************************************************************/
/* This function disables interrupt for IR receiver                                                                     */
/************************************************************************/
void disableIR_ISR(){
	PORTA.PIN3CTRL &= 0b00000000;
     51e:	e0 e0       	ldi	r30, 0x00	; 0
     520:	f4 e0       	ldi	r31, 0x04	; 4
     522:	83 89       	ldd	r24, Z+19	; 0x13
     524:	13 8a       	std	Z+19, r1	; 0x13
     526:	08 95       	ret

00000528 <enableIR_ISR>:
}
/************************************************************************/
/* This function enables interrupt for IR Receiver                                                                     */
/************************************************************************/
void enableIR_ISR(){
	PORTA.PIN3CTRL |= 0b00000011;
     528:	e0 e0       	ldi	r30, 0x00	; 0
     52a:	f4 e0       	ldi	r31, 0x04	; 4
     52c:	83 89       	ldd	r24, Z+19	; 0x13
     52e:	83 60       	ori	r24, 0x03	; 3
     530:	83 8b       	std	Z+19, r24	; 0x13
	RTC.CNT = 0;//reset counter
     532:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     536:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
     53a:	08 95       	ret

0000053c <disableRTC>:
}
void disableRTC(){
	RTC.CNT = 0;//reset counter
     53c:	e0 e4       	ldi	r30, 0x40	; 64
     53e:	f1 e0       	ldi	r31, 0x01	; 1
     540:	10 86       	std	Z+8, r1	; 0x08
     542:	11 86       	std	Z+9, r1	; 0x09
	RTC.INTCTRL &= ~RTC_OVF_bm;
     544:	82 81       	ldd	r24, Z+2	; 0x02
     546:	8e 7f       	andi	r24, 0xFE	; 254
     548:	82 83       	std	Z+2, r24	; 0x02
	tick_counter = 0;
     54a:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <tick_counter>
     54e:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <tick_counter+0x1>
     552:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <tick_counter+0x2>
     556:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <tick_counter+0x3>
     55a:	08 95       	ret

0000055c <enableRTC>:
}
void enableRTC(){
	RTC.INTCTRL |= RTC_OVF_bm;
     55c:	e0 e4       	ldi	r30, 0x40	; 64
     55e:	f1 e0       	ldi	r31, 0x01	; 1
     560:	82 81       	ldd	r24, Z+2	; 0x02
     562:	81 60       	ori	r24, 0x01	; 1
     564:	82 83       	std	Z+2, r24	; 0x02
     566:	08 95       	ret

00000568 <DevModeBlink>:
	
	 
}
void DevModeBlink(){
	PORTD.OUT = 0x00; //Close all motors
     568:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
	switch(DevModeLightState.currentState){
     56c:	80 91 4c 3c 	lds	r24, 0x3C4C	; 0x803c4c <DevModeLightState>
     570:	81 30       	cpi	r24, 0x01	; 1
     572:	89 f0       	breq	.+34     	; 0x596 <DevModeBlink+0x2e>
     574:	28 f0       	brcs	.+10     	; 0x580 <DevModeBlink+0x18>
     576:	82 30       	cpi	r24, 0x02	; 2
     578:	c9 f0       	breq	.+50     	; 0x5ac <DevModeBlink+0x44>
     57a:	83 30       	cpi	r24, 0x03	; 3
     57c:	11 f1       	breq	.+68     	; 0x5c2 <DevModeBlink+0x5a>
     57e:	2b c0       	rjmp	.+86     	; 0x5d6 <DevModeBlink+0x6e>
		case(DEV_ONE):
			PORTA.OUT = 0xFF;
     580:	e0 e0       	ldi	r30, 0x00	; 0
     582:	f4 e0       	ldi	r31, 0x04	; 4
     584:	8f ef       	ldi	r24, 0xFF	; 255
     586:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2);
     588:	84 81       	ldd	r24, Z+4	; 0x04
     58a:	8a 7f       	andi	r24, 0xFA	; 250
     58c:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_TWO;
     58e:	81 e0       	ldi	r24, 0x01	; 1
     590:	80 93 4c 3c 	sts	0x3C4C, r24	; 0x803c4c <DevModeLightState>
		break;
     594:	08 95       	ret
		case(DEV_TWO):
			PORTA.OUT = 0xFF;
     596:	e0 e0       	ldi	r30, 0x00	; 0
     598:	f4 e0       	ldi	r31, 0x04	; 4
     59a:	8f ef       	ldi	r24, 0xFF	; 255
     59c:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_2) & ~(1<<LED_3);
     59e:	84 81       	ldd	r24, Z+4	; 0x04
     5a0:	89 7f       	andi	r24, 0xF9	; 249
     5a2:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_THREE;
     5a4:	82 e0       	ldi	r24, 0x02	; 2
     5a6:	80 93 4c 3c 	sts	0x3C4C, r24	; 0x803c4c <DevModeLightState>
			break;
     5aa:	08 95       	ret
		case(DEV_THREE):
			PORTA.OUT = 0xFF;
     5ac:	e0 e0       	ldi	r30, 0x00	; 0
     5ae:	f4 e0       	ldi	r31, 0x04	; 4
     5b0:	8f ef       	ldi	r24, 0xFF	; 255
     5b2:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_3) & ~(1<<LED_4);
     5b4:	84 81       	ldd	r24, Z+4	; 0x04
     5b6:	8d 7d       	andi	r24, 0xDD	; 221
     5b8:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_FOUR;
     5ba:	83 e0       	ldi	r24, 0x03	; 3
     5bc:	80 93 4c 3c 	sts	0x3C4C, r24	; 0x803c4c <DevModeLightState>
			break;
     5c0:	08 95       	ret
		case(DEV_FOUR):
			PORTA.OUT = 0xFF;
     5c2:	e0 e0       	ldi	r30, 0x00	; 0
     5c4:	f4 e0       	ldi	r31, 0x04	; 4
     5c6:	8f ef       	ldi	r24, 0xFF	; 255
     5c8:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_4);
     5ca:	84 81       	ldd	r24, Z+4	; 0x04
     5cc:	8e 7d       	andi	r24, 0xDE	; 222
     5ce:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_ONE;	
     5d0:	10 92 4c 3c 	sts	0x3C4C, r1	; 0x803c4c <DevModeLightState>
			break;
     5d4:	08 95       	ret
		default:
			DevModeLightState.currentState = DEV_ONE;
     5d6:	10 92 4c 3c 	sts	0x3C4C, r1	; 0x803c4c <DevModeLightState>
			PORTA.OUT = 0xFF;
     5da:	e0 e0       	ldi	r30, 0x00	; 0
     5dc:	f4 e0       	ldi	r31, 0x04	; 4
     5de:	8f ef       	ldi	r24, 0xFF	; 255
     5e0:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_4);
     5e2:	84 81       	ldd	r24, Z+4	; 0x04
     5e4:	8e 7d       	andi	r24, 0xDE	; 222
     5e6:	84 83       	std	Z+4, r24	; 0x04
     5e8:	08 95       	ret

000005ea <setState>:
	}
}

void setState(){
	
	switch(State.currentState){
     5ea:	e0 91 49 3c 	lds	r30, 0x3C49	; 0x803c49 <State>
     5ee:	8e 2f       	mov	r24, r30
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	87 30       	cpi	r24, 0x07	; 7
     5f4:	91 05       	cpc	r25, r1
     5f6:	08 f0       	brcs	.+2      	; 0x5fa <setState+0x10>
     5f8:	5d c0       	rjmp	.+186    	; 0x6b4 <setState+0xca>
     5fa:	fc 01       	movw	r30, r24
     5fc:	e4 59       	subi	r30, 0x94	; 148
     5fe:	ff 4f       	sbci	r31, 0xFF	; 255
     600:	09 94       	ijmp
		case(OFF):
			PORTA.OUT = 0xFF; // All LEDs OFF
     602:	8f ef       	ldi	r24, 0xFF	; 255
     604:	80 93 04 04 	sts	0x0404, r24	; 0x800404 <__RODATA_PM_OFFSET__+0x7fc404>
			PORTD.OUT = 0x00; // All MOTORs OFF
     608:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
			boost_total_timer = 0;//Coming from BOOST state, reset boost timer.
     60c:	10 92 18 3c 	sts	0x3C18, r1	; 0x803c18 <boost_total_timer>
     610:	10 92 19 3c 	sts	0x3C19, r1	; 0x803c19 <boost_total_timer+0x1>
     614:	10 92 1a 3c 	sts	0x3C1A, r1	; 0x803c1a <boost_total_timer+0x2>
     618:	10 92 1b 3c 	sts	0x3C1B, r1	; 0x803c1b <boost_total_timer+0x3>
			break;
     61c:	08 95       	ret
		case(ONE):
			//Only LED_1 is on.
			PORTA.OUT = 0xFF;
     61e:	e0 e0       	ldi	r30, 0x00	; 0
     620:	f4 e0       	ldi	r31, 0x04	; 4
     622:	8f ef       	ldi	r24, 0xFF	; 255
     624:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1);
     626:	84 81       	ldd	r24, Z+4	; 0x04
     628:	8e 7f       	andi	r24, 0xFE	; 254
     62a:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_2);//CLOSE MOTOR_2
     62c:	e0 e6       	ldi	r30, 0x60	; 96
     62e:	f4 e0       	ldi	r31, 0x04	; 4
     630:	84 81       	ldd	r24, Z+4	; 0x04
     632:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_1);//OPEN MOTOR_1
     634:	84 81       	ldd	r24, Z+4	; 0x04
     636:	80 64       	ori	r24, 0x40	; 64
     638:	84 83       	std	Z+4, r24	; 0x04
			break;
     63a:	08 95       	ret
		case(TWO):
			//LEDs 1-2 are on.
			PORTA.OUT = 0xFF;
     63c:	e0 e0       	ldi	r30, 0x00	; 0
     63e:	f4 e0       	ldi	r31, 0x04	; 4
     640:	8f ef       	ldi	r24, 0xFF	; 255
     642:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2);
     644:	84 81       	ldd	r24, Z+4	; 0x04
     646:	8a 7f       	andi	r24, 0xFA	; 250
     648:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_3);//CLOSE MOTOR_3
     64a:	e0 e6       	ldi	r30, 0x60	; 96
     64c:	f4 e0       	ldi	r31, 0x04	; 4
     64e:	84 81       	ldd	r24, Z+4	; 0x04
     650:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_2);//OPEN MOTOR_2
     652:	84 81       	ldd	r24, Z+4	; 0x04
     654:	80 62       	ori	r24, 0x20	; 32
     656:	84 83       	std	Z+4, r24	; 0x04
			
			break;
     658:	08 95       	ret
		case(THREE):
			//LEDs 1-2-3 are on.
			boost_total_timer = 0; // Coming from BOOST state, reset boost timer.
     65a:	10 92 18 3c 	sts	0x3C18, r1	; 0x803c18 <boost_total_timer>
     65e:	10 92 19 3c 	sts	0x3C19, r1	; 0x803c19 <boost_total_timer+0x1>
     662:	10 92 1a 3c 	sts	0x3C1A, r1	; 0x803c1a <boost_total_timer+0x2>
     666:	10 92 1b 3c 	sts	0x3C1B, r1	; 0x803c1b <boost_total_timer+0x3>
			PORTA.OUT = 0xFF;
     66a:	e0 e0       	ldi	r30, 0x00	; 0
     66c:	f4 e0       	ldi	r31, 0x04	; 4
     66e:	8f ef       	ldi	r24, 0xFF	; 255
     670:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2) & ~(1<<LED_3);
     672:	84 81       	ldd	r24, Z+4	; 0x04
     674:	88 7f       	andi	r24, 0xF8	; 248
     676:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_4);//CLOSE MOTOR_4
     678:	e0 e6       	ldi	r30, 0x60	; 96
     67a:	f4 e0       	ldi	r31, 0x04	; 4
     67c:	84 81       	ldd	r24, Z+4	; 0x04
     67e:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_3);//OPEN MOTOR_3
     680:	84 81       	ldd	r24, Z+4	; 0x04
     682:	80 61       	ori	r24, 0x10	; 16
     684:	84 83       	std	Z+4, r24	; 0x04
			
			//
			break;
     686:	08 95       	ret
		case(BOOST):
			//LEDs 1-2-3-4 are on. After 15 min, go to state THREE.
			PORTA.OUT = 0xFF;
     688:	e0 e0       	ldi	r30, 0x00	; 0
     68a:	f4 e0       	ldi	r31, 0x04	; 4
     68c:	8f ef       	ldi	r24, 0xFF	; 255
     68e:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~ (1<<LED_2) & ~ (1<<LED_3) & ~(1<<LED_4);
     690:	84 81       	ldd	r24, Z+4	; 0x04
     692:	88 7d       	andi	r24, 0xD8	; 216
     694:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT |= (1<<MOTOR_RELAY_4);//OPEN MOTOR_4
     696:	e0 e6       	ldi	r30, 0x60	; 96
     698:	f4 e0       	ldi	r31, 0x04	; 4
     69a:	84 81       	ldd	r24, Z+4	; 0x04
     69c:	84 60       	ori	r24, 0x04	; 4
     69e:	84 83       	std	Z+4, r24	; 0x04
			break;
     6a0:	08 95       	ret
		case(DEV_MODE):
				DevModeBlink();
     6a2:	62 df       	rcall	.-316    	; 0x568 <DevModeBlink>
			break;
     6a4:	08 95       	ret
		case(BRIGHT_ADJ):
				PORTA.OUT = 0xFF; // All LEDs OFF
     6a6:	8f ef       	ldi	r24, 0xFF	; 255
     6a8:	80 93 04 04 	sts	0x0404, r24	; 0x800404 <__RODATA_PM_OFFSET__+0x7fc404>
				PORTD.OUT = 0x00; // All MOTORs OFF
     6ac:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
				AdjustBrightness();
     6b0:	4b de       	rcall	.-874    	; 0x348 <AdjustBrightness>
			break;	
     6b2:	08 95       	ret
		default:
			State.currentState = ONE; // In case of errors or out of state machine, go to state one.
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     6ba:	08 95       	ret

000006bc <WriteInput>:
/************************************************************************/
/* This function changes the State of the system according to the input from the controller                                                                     */
/************************************************************************/
void WriteInput(){
	
	switch(InputState.currentState){
     6bc:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
     6c0:	82 30       	cpi	r24, 0x02	; 2
     6c2:	e1 f0       	breq	.+56     	; 0x6fc <WriteInput+0x40>
     6c4:	18 f4       	brcc	.+6      	; 0x6cc <WriteInput+0x10>
     6c6:	88 23       	and	r24, r24
     6c8:	39 f0       	breq	.+14     	; 0x6d8 <WriteInput+0x1c>
     6ca:	08 95       	ret
     6cc:	84 30       	cpi	r24, 0x04	; 4
     6ce:	91 f1       	breq	.+100    	; 0x734 <WriteInput+0x78>
     6d0:	86 30       	cpi	r24, 0x06	; 6
     6d2:	09 f4       	brne	.+2      	; 0x6d6 <WriteInput+0x1a>
     6d4:	4b c0       	rjmp	.+150    	; 0x76c <WriteInput+0xb0>
     6d6:	08 95       	ret
		case(POWER):
			if(State.currentState == OFF){
     6d8:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
     6dc:	81 11       	cpse	r24, r1
     6de:	07 c0       	rjmp	.+14     	; 0x6ee <WriteInput+0x32>
				State.currentState = ONE;
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
				BuzzerState.currentState= POWER_ON_SOUND;
     6e6:	10 92 4e 3c 	sts	0x3C4E, r1	; 0x803c4e <BuzzerState>
				Buzzer();
     6ea:	18 dd       	rcall	.-1488   	; 0x11c <Buzzer>
     6ec:	08 95       	ret
			}
			else{
				State.currentState = OFF;
     6ee:	10 92 49 3c 	sts	0x3C49, r1	; 0x803c49 <State>
				BuzzerState.currentState= POWER_OFF_SOUND;
     6f2:	81 e0       	ldi	r24, 0x01	; 1
     6f4:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
				Buzzer();
     6f8:	11 dd       	rcall	.-1502   	; 0x11c <Buzzer>
     6fa:	08 95       	ret
			}
			break;
		case(INCREMENT):
			BuzzerState.currentState= INC_SOUND;
     6fc:	82 e0       	ldi	r24, 0x02	; 2
     6fe:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
     702:	0c dd       	rcall	.-1512   	; 0x11c <Buzzer>
			if(State.currentState==ONE){
     704:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
     708:	81 30       	cpi	r24, 0x01	; 1
     70a:	21 f4       	brne	.+8      	; 0x714 <WriteInput+0x58>
				State.currentState = TWO;
     70c:	82 e0       	ldi	r24, 0x02	; 2
     70e:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     712:	08 95       	ret
			}
			else if(State.currentState == TWO){
     714:	82 30       	cpi	r24, 0x02	; 2
     716:	21 f4       	brne	.+8      	; 0x720 <WriteInput+0x64>
				State.currentState=THREE;
     718:	83 e0       	ldi	r24, 0x03	; 3
     71a:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     71e:	08 95       	ret
			}
			else if(State.currentState == THREE) {
     720:	83 30       	cpi	r24, 0x03	; 3
     722:	21 f4       	brne	.+8      	; 0x72c <WriteInput+0x70>
				State.currentState = BOOST;
     724:	84 e0       	ldi	r24, 0x04	; 4
     726:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     72a:	08 95       	ret
			}
			else if(State.currentState==BRIGHT_ADJ){
     72c:	86 30       	cpi	r24, 0x06	; 6
     72e:	61 f5       	brne	.+88     	; 0x788 <WriteInput+0xcc>
				incrementLight();
     730:	59 de       	rcall	.-846    	; 0x3e4 <incrementLight>
     732:	08 95       	ret
			}
			break;
		case(DECREMENT):
			BuzzerState.currentState= DEC_SOUND;
     734:	83 e0       	ldi	r24, 0x03	; 3
     736:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
     73a:	f0 dc       	rcall	.-1568   	; 0x11c <Buzzer>
			if(State.currentState==BOOST){
     73c:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	21 f4       	brne	.+8      	; 0x74c <WriteInput+0x90>
				State.currentState = THREE;
     744:	83 e0       	ldi	r24, 0x03	; 3
     746:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     74a:	08 95       	ret
			}
			else if(State.currentState == THREE){
     74c:	83 30       	cpi	r24, 0x03	; 3
     74e:	21 f4       	brne	.+8      	; 0x758 <WriteInput+0x9c>
				State.currentState=TWO;
     750:	82 e0       	ldi	r24, 0x02	; 2
     752:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     756:	08 95       	ret
			}
			else if(State.currentState == TWO) {
     758:	82 30       	cpi	r24, 0x02	; 2
     75a:	21 f4       	brne	.+8      	; 0x764 <WriteInput+0xa8>
				State.currentState = ONE;
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
     762:	08 95       	ret
			}
			else if(State.currentState==BRIGHT_ADJ){
     764:	86 30       	cpi	r24, 0x06	; 6
     766:	81 f4       	brne	.+32     	; 0x788 <WriteInput+0xcc>
				decrementLight();
     768:	6c de       	rcall	.-808    	; 0x442 <decrementLight>
     76a:	08 95       	ret
			}
			break;
		case(LIGHT):
			if(LightState.currentState == LIGHT_ON){
     76c:	80 91 44 3c 	lds	r24, 0x3C44	; 0x803c44 <LightState>
     770:	81 11       	cpse	r24, r1
     772:	04 c0       	rjmp	.+8      	; 0x77c <WriteInput+0xc0>
				LightState.currentState=LIGHT_OFF;
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	80 93 44 3c 	sts	0x3C44, r24	; 0x803c44 <LightState>
     77a:	02 c0       	rjmp	.+4      	; 0x780 <WriteInput+0xc4>
			}
			else{
				LightState.currentState=LIGHT_ON;
     77c:	10 92 44 3c 	sts	0x3C44, r1	; 0x803c44 <LightState>
			}
			BuzzerState.currentState= LIGHT_SOUND;
     780:	84 e0       	ldi	r24, 0x04	; 4
     782:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
     786:	ca dc       	rcall	.-1644   	; 0x11c <Buzzer>
     788:	08 95       	ret

0000078a <DecodeCommand>:
/* This functions decodes incoming command. There are 4 different commands which are;
POWER, INCREMENT, DECREMENT and  LIGHT. There can also be REPEAT code which happens when the button 
is held down.Functions changes the current state of InputState instance.                                                                     */
/************************************************************************/
void DecodeCommand(){
	if((command_register&0x0000FFFF)==IR_POWER_bm){
     78a:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     78e:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     792:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     796:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     79a:	aa 27       	eor	r26, r26
     79c:	bb 27       	eor	r27, r27
     79e:	8e 37       	cpi	r24, 0x7E	; 126
     7a0:	91 48       	sbci	r25, 0x81	; 129
     7a2:	a1 05       	cpc	r26, r1
     7a4:	b1 05       	cpc	r27, r1
     7a6:	29 f4       	brne	.+10     	; 0x7b2 <DecodeCommand+0x28>
		InputState.currentState = POWER;
     7a8:	10 92 45 3c 	sts	0x3C45, r1	; 0x803c45 <InputState>
		WriteInput();
     7ac:	87 df       	rcall	.-242    	; 0x6bc <WriteInput>
		setState();
     7ae:	1d df       	rcall	.-454    	; 0x5ea <setState>
		return;
     7b0:	08 95       	ret
	}
	else if((command_register&0x0000FFFF)==IR_MINUS_bm){
     7b2:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     7b6:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     7ba:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     7be:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     7c2:	aa 27       	eor	r26, r26
     7c4:	bb 27       	eor	r27, r27
     7c6:	8e 3a       	cpi	r24, 0xAE	; 174
     7c8:	91 45       	sbci	r25, 0x51	; 81
     7ca:	a1 05       	cpc	r26, r1
     7cc:	b1 05       	cpc	r27, r1
     7ce:	31 f4       	brne	.+12     	; 0x7dc <DecodeCommand+0x52>
		InputState.currentState = DECREMENT;
     7d0:	84 e0       	ldi	r24, 0x04	; 4
     7d2:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
		WriteInput();
     7d6:	72 df       	rcall	.-284    	; 0x6bc <WriteInput>
		setState();
     7d8:	08 df       	rcall	.-496    	; 0x5ea <setState>
		return;
     7da:	08 95       	ret
	}
	else if ((command_register&0x0000FFFF)==IR_PLUS_bm){
     7dc:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     7e0:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     7e4:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     7e8:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     7ec:	aa 27       	eor	r26, r26
     7ee:	bb 27       	eor	r27, r27
     7f0:	8e 35       	cpi	r24, 0x5E	; 94
     7f2:	91 4a       	sbci	r25, 0xA1	; 161
     7f4:	a1 05       	cpc	r26, r1
     7f6:	b1 05       	cpc	r27, r1
     7f8:	31 f4       	brne	.+12     	; 0x806 <DecodeCommand+0x7c>
		InputState.currentState = INCREMENT;
     7fa:	82 e0       	ldi	r24, 0x02	; 2
     7fc:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
		WriteInput();
     800:	5d df       	rcall	.-326    	; 0x6bc <WriteInput>
		setState();
     802:	f3 de       	rcall	.-538    	; 0x5ea <setState>
		return;
     804:	08 95       	ret
	}
	else if((command_register&0x0000FFFF)==IR_LIGHT_bm){
     806:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     80a:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     80e:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     812:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     816:	aa 27       	eor	r26, r26
     818:	bb 27       	eor	r27, r27
     81a:	86 36       	cpi	r24, 0x66	; 102
     81c:	99 49       	sbci	r25, 0x99	; 153
     81e:	a1 05       	cpc	r26, r1
     820:	b1 05       	cpc	r27, r1
     822:	21 f4       	brne	.+8      	; 0x82c <DecodeCommand+0xa2>
		InputState.currentState = LIGHT;
     824:	86 e0       	ldi	r24, 0x06	; 6
     826:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
		WriteInput();
     82a:	48 df       	rcall	.-368    	; 0x6bc <WriteInput>
     82c:	08 95       	ret

0000082e <IR_Read>:
state of the INPUT_STATE                                                                    */
/************************************************************************/
//IR Read function to decode incoming signal.
void IR_Read(){
	//If the signal is HIGH for 9ms, this means we are in START.
	switch(NECState.currentState){
     82e:	80 91 4a 3c 	lds	r24, 0x3C4A	; 0x803c4a <NECState>
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	21 f0       	breq	.+8      	; 0x83e <IR_Read+0x10>
     836:	83 30       	cpi	r24, 0x03	; 3
     838:	09 f4       	brne	.+2      	; 0x83c <IR_Read+0xe>
     83a:	f7 c1       	rjmp	.+1006   	; 0xc2a <IR_Read+0x3fc>
     83c:	08 95       	ret
			
		case(COMMAND):
		
			idle_flag=1;
     83e:	81 e0       	ldi	r24, 0x01	; 1
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	80 93 32 3c 	sts	0x3C32, r24	; 0x803c32 <idle_flag>
     846:	90 93 33 3c 	sts	0x3C33, r25	; 0x803c33 <idle_flag+0x1>
			cli();
     84a:	f8 94       	cli
			RTC.CNT = 0;
     84c:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     850:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     854:	78 94       	sei
			//start timer
			
			disableIR_ISR();
     856:	63 de       	rcall	.-826    	; 0x51e <disableIR_ISR>
			while(((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 9000){
     858:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     85c:	83 fd       	sbrc	r24, 3
     85e:	10 c0       	rjmp	.+32     	; 0x880 <IR_Read+0x52>
     860:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     864:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     868:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     86c:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     870:	aa e7       	ldi	r26, 0x7A	; 122
     872:	b0 e0       	ldi	r27, 0x00	; 0
     874:	af d5       	rcall	.+2910   	; 0x13d4 <__muluhisi3>
     876:	69 32       	cpi	r22, 0x29	; 41
     878:	73 42       	sbci	r23, 0x23	; 35
     87a:	81 05       	cpc	r24, r1
     87c:	91 05       	cpc	r25, r1
     87e:	64 f3       	brlt	.-40     	; 0x858 <IR_Read+0x2a>
				
			}
			counter = 0;
     880:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     884:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     888:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     88c:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
			cli();
     890:	f8 94       	cli
			RTC.CNT = 0;
     892:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     896:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     89a:	78 94       	sei
			
			while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 4500){
     89c:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     8a0:	83 ff       	sbrs	r24, 3
     8a2:	10 c0       	rjmp	.+32     	; 0x8c4 <IR_Read+0x96>
     8a4:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     8a8:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     8ac:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     8b0:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     8b4:	aa e7       	ldi	r26, 0x7A	; 122
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	8d d5       	rcall	.+2842   	; 0x13d4 <__muluhisi3>
     8ba:	65 39       	cpi	r22, 0x95	; 149
     8bc:	71 41       	sbci	r23, 0x11	; 17
     8be:	81 05       	cpc	r24, r1
     8c0:	91 05       	cpc	r25, r1
     8c2:	64 f3       	brlt	.-40     	; 0x89c <IR_Read+0x6e>
				
			}
			if(counter*RTC_TICK <= 2300){
     8c4:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     8c8:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     8cc:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     8d0:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     8d4:	aa e7       	ldi	r26, 0x7A	; 122
     8d6:	b0 e0       	ldi	r27, 0x00	; 0
     8d8:	7d d5       	rcall	.+2810   	; 0x13d4 <__muluhisi3>
     8da:	6d 3f       	cpi	r22, 0xFD	; 253
     8dc:	78 40       	sbci	r23, 0x08	; 8
     8de:	81 05       	cpc	r24, r1
     8e0:	91 05       	cpc	r25, r1
     8e2:	0c f0       	brlt	.+2      	; 0x8e6 <IR_Read+0xb8>
     8e4:	41 c0       	rjmp	.+130    	; 0x968 <IR_Read+0x13a>
				//Repeat Case
				counter = 0;
     8e6:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     8ea:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     8ee:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     8f2:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
				disableRTC();//reset timer
     8f6:	22 de       	rcall	.-956    	; 0x53c <disableRTC>
				enableRTC();
     8f8:	31 de       	rcall	.-926    	; 0x55c <enableRTC>
				cli();
     8fa:	f8 94       	cli
				RTC.CNT = 0;
     8fc:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     900:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     904:	78 94       	sei
				counter = 0;
     906:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     90a:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     90e:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     912:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
				while(((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 600){
     916:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     91a:	83 fd       	sbrc	r24, 3
     91c:	10 c0       	rjmp	.+32     	; 0x93e <IR_Read+0x110>
     91e:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     922:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     926:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     92a:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     92e:	aa e7       	ldi	r26, 0x7A	; 122
     930:	b0 e0       	ldi	r27, 0x00	; 0
     932:	50 d5       	rcall	.+2720   	; 0x13d4 <__muluhisi3>
     934:	69 35       	cpi	r22, 0x59	; 89
     936:	72 40       	sbci	r23, 0x02	; 2
     938:	81 05       	cpc	r24, r1
     93a:	91 05       	cpc	r25, r1
     93c:	64 f3       	brlt	.-40     	; 0x916 <IR_Read+0xe8>
					//end of message
				}
				
				GenerateRepeatCode();
     93e:	c2 dd       	rcall	.-1148   	; 0x4c4 <GenerateRepeatCode>
				
				counter=0;
     940:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     944:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     948:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     94c:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
				idle_flag=0;
     950:	10 92 32 3c 	sts	0x3C32, r1	; 0x803c32 <idle_flag>
     954:	10 92 33 3c 	sts	0x3C33, r1	; 0x803c33 <idle_flag+0x1>
				cli();
     958:	f8 94       	cli
				RTC.CNT = 0;
     95a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     95e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     962:	78 94       	sei
				
				enableIR_ISR();
     964:	e1 dd       	rcall	.-1086   	; 0x528 <enableIR_ISR>
				break;
     966:	08 95       	ret
			}
			
			//hold_counter = 0; // Reset hold counter if not received repeat signal.
			cli();
     968:	f8 94       	cli
			RTC.CNT = 0;
     96a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     96e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     972:	78 94       	sei
			counter = 0;
     974:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     978:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     97c:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     980:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
			idle_flag=0;
     984:	10 92 32 3c 	sts	0x3C32, r1	; 0x803c32 <idle_flag>
     988:	10 92 33 3c 	sts	0x3C33, r1	; 0x803c33 <idle_flag+0x1>
			command_counter_flag=1;
     98c:	81 e0       	ldi	r24, 0x01	; 1
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	80 93 30 3c 	sts	0x3C30, r24	; 0x803c30 <command_counter_flag>
     994:	90 93 31 3c 	sts	0x3C31, r25	; 0x803c31 <command_counter_flag+0x1>
			for(i=0;i<33;i++){
     998:	10 92 47 3c 	sts	0x3C47, r1	; 0x803c47 <i>
     99c:	10 92 48 3c 	sts	0x3C48, r1	; 0x803c48 <i+0x1>
     9a0:	ca c0       	rjmp	.+404    	; 0xb36 <IR_Read+0x308>
				tick_counter=0;
     9a2:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <tick_counter>
     9a6:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <tick_counter+0x1>
     9aa:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <tick_counter+0x2>
     9ae:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <tick_counter+0x3>
				while(((PORTA.IN & (1<<IR_INPUT)) == 0)&&tick_counter*RTC_TICK<=650){
     9b2:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     9b6:	83 fd       	sbrc	r24, 3
     9b8:	10 c0       	rjmp	.+32     	; 0x9da <IR_Read+0x1ac>
     9ba:	20 91 2c 3c 	lds	r18, 0x3C2C	; 0x803c2c <tick_counter>
     9be:	30 91 2d 3c 	lds	r19, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     9c2:	40 91 2e 3c 	lds	r20, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     9c6:	50 91 2f 3c 	lds	r21, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     9ca:	aa e7       	ldi	r26, 0x7A	; 122
     9cc:	b0 e0       	ldi	r27, 0x00	; 0
     9ce:	02 d5       	rcall	.+2564   	; 0x13d4 <__muluhisi3>
     9d0:	6b 38       	cpi	r22, 0x8B	; 139
     9d2:	72 40       	sbci	r23, 0x02	; 2
     9d4:	81 05       	cpc	r24, r1
     9d6:	91 05       	cpc	r25, r1
     9d8:	64 f3       	brlt	.-40     	; 0x9b2 <IR_Read+0x184>
					//loop until next space
				}
				
				tick_counter=0;
     9da:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <tick_counter>
     9de:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <tick_counter+0x1>
     9e2:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <tick_counter+0x2>
     9e6:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <tick_counter+0x3>
				disableRTC();//reset timer
     9ea:	a8 dd       	rcall	.-1200   	; 0x53c <disableRTC>
				enableRTC();
     9ec:	b7 dd       	rcall	.-1170   	; 0x55c <enableRTC>
				while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&&tick_counter*RTC_TICK<=1800){
     9ee:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     9f2:	83 ff       	sbrs	r24, 3
     9f4:	10 c0       	rjmp	.+32     	; 0xa16 <IR_Read+0x1e8>
     9f6:	20 91 2c 3c 	lds	r18, 0x3C2C	; 0x803c2c <tick_counter>
     9fa:	30 91 2d 3c 	lds	r19, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     9fe:	40 91 2e 3c 	lds	r20, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     a02:	50 91 2f 3c 	lds	r21, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     a06:	aa e7       	ldi	r26, 0x7A	; 122
     a08:	b0 e0       	ldi	r27, 0x00	; 0
     a0a:	e4 d4       	rcall	.+2504   	; 0x13d4 <__muluhisi3>
     a0c:	69 30       	cpi	r22, 0x09	; 9
     a0e:	77 40       	sbci	r23, 0x07	; 7
     a10:	81 05       	cpc	r24, r1
     a12:	91 05       	cpc	r25, r1
     a14:	64 f3       	brlt	.-40     	; 0x9ee <IR_Read+0x1c0>
					//loop until next pulse
				}
				if(i==32 && tick_counter*RTC_TICK> 1000){//end of message
     a16:	80 91 47 3c 	lds	r24, 0x3C47	; 0x803c47 <i>
     a1a:	90 91 48 3c 	lds	r25, 0x3C48	; 0x803c48 <i+0x1>
     a1e:	80 97       	sbiw	r24, 0x20	; 32
     a20:	89 f4       	brne	.+34     	; 0xa44 <IR_Read+0x216>
     a22:	20 91 2c 3c 	lds	r18, 0x3C2C	; 0x803c2c <tick_counter>
     a26:	30 91 2d 3c 	lds	r19, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     a2a:	40 91 2e 3c 	lds	r20, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     a2e:	50 91 2f 3c 	lds	r21, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     a32:	aa e7       	ldi	r26, 0x7A	; 122
     a34:	b0 e0       	ldi	r27, 0x00	; 0
     a36:	ce d4       	rcall	.+2460   	; 0x13d4 <__muluhisi3>
     a38:	69 3e       	cpi	r22, 0xE9	; 233
     a3a:	73 40       	sbci	r23, 0x03	; 3
     a3c:	81 05       	cpc	r24, r1
     a3e:	91 05       	cpc	r25, r1
     a40:	0c f0       	brlt	.+2      	; 0xa44 <IR_Read+0x216>
     a42:	80 c0       	rjmp	.+256    	; 0xb44 <IR_Read+0x316>
					break;
				}
				if( tick_counter*RTC_TICK> 1000)   {                            
     a44:	20 91 2c 3c 	lds	r18, 0x3C2C	; 0x803c2c <tick_counter>
     a48:	30 91 2d 3c 	lds	r19, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     a4c:	40 91 2e 3c 	lds	r20, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     a50:	50 91 2f 3c 	lds	r21, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     a54:	aa e7       	ldi	r26, 0x7A	; 122
     a56:	b0 e0       	ldi	r27, 0x00	; 0
     a58:	bd d4       	rcall	.+2426   	; 0x13d4 <__muluhisi3>
     a5a:	69 3e       	cpi	r22, 0xE9	; 233
     a5c:	73 40       	sbci	r23, 0x03	; 3
     a5e:	81 05       	cpc	r24, r1
     a60:	91 05       	cpc	r25, r1
     a62:	b4 f1       	brlt	.+108    	; 0xad0 <IR_Read+0x2a2>
					command_register = command_register<<1;   
     a64:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     a68:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     a6c:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     a70:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     a74:	88 0f       	add	r24, r24
     a76:	99 1f       	adc	r25, r25
     a78:	aa 1f       	adc	r26, r26
     a7a:	bb 1f       	adc	r27, r27
     a7c:	80 93 26 3c 	sts	0x3C26, r24	; 0x803c26 <command_register>
     a80:	90 93 27 3c 	sts	0x3C27, r25	; 0x803c27 <command_register+0x1>
     a84:	a0 93 28 3c 	sts	0x3C28, r26	; 0x803c28 <command_register+0x2>
     a88:	b0 93 29 3c 	sts	0x3C29, r27	; 0x803c29 <command_register+0x3>
					command_register |= 0x01;
     a8c:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     a90:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     a94:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     a98:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     a9c:	81 60       	ori	r24, 0x01	; 1
     a9e:	80 93 26 3c 	sts	0x3C26, r24	; 0x803c26 <command_register>
     aa2:	90 93 27 3c 	sts	0x3C27, r25	; 0x803c27 <command_register+0x1>
     aa6:	a0 93 28 3c 	sts	0x3C28, r26	; 0x803c28 <command_register+0x2>
     aaa:	b0 93 29 3c 	sts	0x3C29, r27	; 0x803c29 <command_register+0x3>
					tick_counter=tick_counter;
     aae:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <tick_counter>
     ab2:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     ab6:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     aba:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     abe:	80 93 2c 3c 	sts	0x3C2C, r24	; 0x803c2c <tick_counter>
     ac2:	90 93 2d 3c 	sts	0x3C2D, r25	; 0x803c2d <tick_counter+0x1>
     ac6:	a0 93 2e 3c 	sts	0x3C2E, r26	; 0x803c2e <tick_counter+0x2>
     aca:	b0 93 2f 3c 	sts	0x3C2F, r27	; 0x803c2f <tick_counter+0x3>
     ace:	24 c0       	rjmp	.+72     	; 0xb18 <IR_Read+0x2ea>
				    }                
				else    {                                         
					command_register = command_register<<1;
     ad0:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <command_register>
     ad4:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <command_register+0x1>
     ad8:	a0 91 28 3c 	lds	r26, 0x3C28	; 0x803c28 <command_register+0x2>
     adc:	b0 91 29 3c 	lds	r27, 0x3C29	; 0x803c29 <command_register+0x3>
     ae0:	88 0f       	add	r24, r24
     ae2:	99 1f       	adc	r25, r25
     ae4:	aa 1f       	adc	r26, r26
     ae6:	bb 1f       	adc	r27, r27
     ae8:	80 93 26 3c 	sts	0x3C26, r24	; 0x803c26 <command_register>
     aec:	90 93 27 3c 	sts	0x3C27, r25	; 0x803c27 <command_register+0x1>
     af0:	a0 93 28 3c 	sts	0x3C28, r26	; 0x803c28 <command_register+0x2>
     af4:	b0 93 29 3c 	sts	0x3C29, r27	; 0x803c29 <command_register+0x3>
					tick_counter=tick_counter;
     af8:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <tick_counter>
     afc:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     b00:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     b04:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     b08:	80 93 2c 3c 	sts	0x3C2C, r24	; 0x803c2c <tick_counter>
     b0c:	90 93 2d 3c 	sts	0x3C2D, r25	; 0x803c2d <tick_counter+0x1>
     b10:	a0 93 2e 3c 	sts	0x3C2E, r26	; 0x803c2e <tick_counter+0x2>
     b14:	b0 93 2f 3c 	sts	0x3C2F, r27	; 0x803c2f <tick_counter+0x3>
				}
				
				
				cli();
     b18:	f8 94       	cli
				RTC.CNT = 0;
     b1a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     b1e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     b22:	78 94       	sei
			RTC.CNT = 0;
			sei();
			counter = 0;
			idle_flag=0;
			command_counter_flag=1;
			for(i=0;i<33;i++){
     b24:	80 91 47 3c 	lds	r24, 0x3C47	; 0x803c47 <i>
     b28:	90 91 48 3c 	lds	r25, 0x3C48	; 0x803c48 <i+0x1>
     b2c:	01 96       	adiw	r24, 0x01	; 1
     b2e:	80 93 47 3c 	sts	0x3C47, r24	; 0x803c47 <i>
     b32:	90 93 48 3c 	sts	0x3C48, r25	; 0x803c48 <i+0x1>
     b36:	80 91 47 3c 	lds	r24, 0x3C47	; 0x803c47 <i>
     b3a:	90 91 48 3c 	lds	r25, 0x3C48	; 0x803c48 <i+0x1>
     b3e:	81 97       	sbiw	r24, 0x21	; 33
     b40:	0c f4       	brge	.+2      	; 0xb44 <IR_Read+0x316>
     b42:	2f cf       	rjmp	.-418    	; 0x9a2 <IR_Read+0x174>
			}
			//wait for end bit. It is a inverse pulse for 500 us
			//If any signal comes in 40ms it is repeat
			//If not go to idle case.
			
			if(VerifyAddress()){
     b44:	ad dc       	rcall	.-1702   	; 0x4a0 <VerifyAddress>
     b46:	81 11       	cpse	r24, r1
				DecodeCommand();
     b48:	20 de       	rcall	.-960    	; 0x78a <DecodeCommand>
			}
			
			idle_flag=1;
     b4a:	81 e0       	ldi	r24, 0x01	; 1
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	80 93 32 3c 	sts	0x3C32, r24	; 0x803c32 <idle_flag>
     b52:	90 93 33 3c 	sts	0x3C33, r25	; 0x803c33 <idle_flag+0x1>
			counter = 0;
     b56:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     b5a:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     b5e:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     b62:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
			cli();
     b66:	f8 94       	cli
			RTC.CNT = 0;
     b68:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     b6c:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     b70:	78 94       	sei
			//If we did not received messages for more than 100 ms, it means no repeat. Change flag
			while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 50000){
     b72:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     b76:	83 ff       	sbrs	r24, 3
     b78:	10 c0       	rjmp	.+32     	; 0xb9a <IR_Read+0x36c>
     b7a:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     b7e:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     b82:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     b86:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     b8a:	aa e7       	ldi	r26, 0x7A	; 122
     b8c:	b0 e0       	ldi	r27, 0x00	; 0
     b8e:	22 d4       	rcall	.+2116   	; 0x13d4 <__muluhisi3>
     b90:	61 35       	cpi	r22, 0x51	; 81
     b92:	73 4c       	sbci	r23, 0xC3	; 195
     b94:	81 05       	cpc	r24, r1
     b96:	91 05       	cpc	r25, r1
     b98:	64 f3       	brlt	.-40     	; 0xb72 <IR_Read+0x344>
				
			}
			if(counter*RTC_TICK >= 40000){
     b9a:	20 91 34 3c 	lds	r18, 0x3C34	; 0x803c34 <counter>
     b9e:	30 91 35 3c 	lds	r19, 0x3C35	; 0x803c35 <counter+0x1>
     ba2:	40 91 36 3c 	lds	r20, 0x3C36	; 0x803c36 <counter+0x2>
     ba6:	50 91 37 3c 	lds	r21, 0x3C37	; 0x803c37 <counter+0x3>
     baa:	aa e7       	ldi	r26, 0x7A	; 122
     bac:	b0 e0       	ldi	r27, 0x00	; 0
     bae:	12 d4       	rcall	.+2084   	; 0x13d4 <__muluhisi3>
     bb0:	60 34       	cpi	r22, 0x40	; 64
     bb2:	7c 49       	sbci	r23, 0x9C	; 156
     bb4:	81 05       	cpc	r24, r1
     bb6:	91 05       	cpc	r25, r1
     bb8:	24 f1       	brlt	.+72     	; 0xc02 <IR_Read+0x3d4>
				hold_flag=0;
     bba:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <hold_flag>
     bbe:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <hold_flag+0x1>
				hold_counter = 0;
     bc2:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <hold_counter>
     bc6:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <hold_counter+0x1>
     bca:	10 92 24 3c 	sts	0x3C24, r1	; 0x803c24 <hold_counter+0x2>
     bce:	10 92 25 3c 	sts	0x3C25, r1	; 0x803c25 <hold_counter+0x3>
				if(InputState.currentState==POWER_HOLD){
     bd2:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
     bd6:	81 30       	cpi	r24, 0x01	; 1
     bd8:	19 f4       	brne	.+6      	; 0xbe0 <IR_Read+0x3b2>
					InputState.currentState=POWER;
     bda:	10 92 45 3c 	sts	0x3C45, r1	; 0x803c45 <InputState>
     bde:	11 c0       	rjmp	.+34     	; 0xc02 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==INCREMENT_HOLD){
     be0:	83 30       	cpi	r24, 0x03	; 3
     be2:	21 f4       	brne	.+8      	; 0xbec <IR_Read+0x3be>
					InputState.currentState=INCREMENT;
     be4:	82 e0       	ldi	r24, 0x02	; 2
     be6:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     bea:	0b c0       	rjmp	.+22     	; 0xc02 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==DECREMENT_HOLD){
     bec:	85 30       	cpi	r24, 0x05	; 5
     bee:	21 f4       	brne	.+8      	; 0xbf8 <IR_Read+0x3ca>
					InputState.currentState=DECREMENT;
     bf0:	84 e0       	ldi	r24, 0x04	; 4
     bf2:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
     bf6:	05 c0       	rjmp	.+10     	; 0xc02 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==LIGHT_HOLD){
     bf8:	87 30       	cpi	r24, 0x07	; 7
     bfa:	19 f4       	brne	.+6      	; 0xc02 <IR_Read+0x3d4>
					InputState.currentState=LIGHT;
     bfc:	86 e0       	ldi	r24, 0x06	; 6
     bfe:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
				}
			}
			idle_flag=0;
     c02:	10 92 32 3c 	sts	0x3C32, r1	; 0x803c32 <idle_flag>
     c06:	10 92 33 3c 	sts	0x3C33, r1	; 0x803c33 <idle_flag+0x1>
			tick_counter=0;
     c0a:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <tick_counter>
     c0e:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <tick_counter+0x1>
     c12:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <tick_counter+0x2>
     c16:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <tick_counter+0x3>
			cli();
     c1a:	f8 94       	cli
			RTC.CNT = 0;
     c1c:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     c20:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     c24:	78 94       	sei
			
			enableIR_ISR();
     c26:	80 dc       	rcall	.-1792   	; 0x528 <enableIR_ISR>
			//disable timer in the end
			break;
     c28:	08 95       	ret
		
		case(END):
			counter=0;
     c2a:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <counter>
     c2e:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <counter+0x1>
     c32:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <counter+0x2>
     c36:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <counter+0x3>
     c3a:	08 95       	ret

00000c3c <EEPROM_read>:
But we did not succeeded.                                                                     */
/************************************************************************/
uint64_t EEPROM_read(){
	uint64_t * pointer = EEPROM_START;
	uint64_t data = 0;
	data = *pointer;
     c3c:	e0 e0       	ldi	r30, 0x00	; 0
     c3e:	f4 e1       	ldi	r31, 0x14	; 20
     c40:	20 81       	ld	r18, Z
     c42:	31 81       	ldd	r19, Z+1	; 0x01
     c44:	42 81       	ldd	r20, Z+2	; 0x02
     c46:	53 81       	ldd	r21, Z+3	; 0x03
     c48:	64 81       	ldd	r22, Z+4	; 0x04
     c4a:	75 81       	ldd	r23, Z+5	; 0x05
	
	
	return data;
}
     c4c:	86 81       	ldd	r24, Z+6	; 0x06
     c4e:	97 81       	ldd	r25, Z+7	; 0x07
     c50:	08 95       	ret

00000c52 <EEPROM_write>:
/************************************************************************/
/* This function writes brightness level to the EEPROM memory.                                                                     */
/************************************************************************/
void EEPROM_write(BRIGHT_MODE_STATE_INFO level){
     c52:	e8 2f       	mov	r30, r24
	while((NVMCTRL.STATUS&(0x01))==0x01); // Check for FBUSY
     c54:	90 91 02 10 	lds	r25, 0x1002	; 0x801002 <__RODATA_PM_OFFSET__+0x7fd002>
     c58:	90 fd       	sbrc	r25, 0
     c5a:	fc cf       	rjmp	.-8      	; 0xc54 <EEPROM_write+0x2>
	while((NVMCTRL.STATUS&(0x02))==0x01); // Check for EEBUSY
     c5c:	a0 e0       	ldi	r26, 0x00	; 0
     c5e:	b0 e1       	ldi	r27, 0x10	; 16
     c60:	12 96       	adiw	r26, 0x02	; 2
     c62:	8c 91       	ld	r24, X
     c64:	12 97       	sbiw	r26, 0x02	; 2
	uint8_t data = 0;
	NVMCTRL.ADDRL = EEPROM_DATA_ADDRESS_LOW;
     c66:	18 96       	adiw	r26, 0x08	; 8
     c68:	1c 92       	st	X, r1
     c6a:	18 97       	sbiw	r26, 0x08	; 8
	NVMCTRL.ADDRH = EEPROM_DATA_ADDRESS_HIGH;
     c6c:	84 e1       	ldi	r24, 0x14	; 20
     c6e:	19 96       	adiw	r26, 0x09	; 9
     c70:	8c 93       	st	X, r24
	switch(level.currentState){
     c72:	8e 2f       	mov	r24, r30
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	8a 30       	cpi	r24, 0x0A	; 10
     c78:	91 05       	cpc	r25, r1
     c7a:	58 f5       	brcc	.+86     	; 0xcd2 <EEPROM_write+0x80>
     c7c:	fc 01       	movw	r30, r24
     c7e:	ed 58       	subi	r30, 0x8D	; 141
     c80:	ff 4f       	sbci	r31, 0xFF	; 255
     c82:	09 94       	ijmp
		case(BRIGHT_ONE):
			data = 1;
			NVMCTRL.DATAL = data;
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     c8a:	23 c0       	rjmp	.+70     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_TWO):
		data = 2;
		NVMCTRL.DATAL = data;
     c8c:	82 e0       	ldi	r24, 0x02	; 2
     c8e:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     c92:	1f c0       	rjmp	.+62     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_THREE):
		data = 3;
		NVMCTRL.DATAL = data;
     c94:	83 e0       	ldi	r24, 0x03	; 3
     c96:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     c9a:	1b c0       	rjmp	.+54     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_FOUR):
		data = 4;
		NVMCTRL.DATAL = data;
     c9c:	84 e0       	ldi	r24, 0x04	; 4
     c9e:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     ca2:	17 c0       	rjmp	.+46     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_FIVE):
		data = 5;
		NVMCTRL.DATAL = data;
     ca4:	85 e0       	ldi	r24, 0x05	; 5
     ca6:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     caa:	13 c0       	rjmp	.+38     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_SIX):
		data = 6;
		NVMCTRL.DATAL = data;
     cac:	86 e0       	ldi	r24, 0x06	; 6
     cae:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     cb2:	0f c0       	rjmp	.+30     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_SEVEN):
		data = 7;
		NVMCTRL.DATAL = data;
     cb4:	87 e0       	ldi	r24, 0x07	; 7
     cb6:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     cba:	0b c0       	rjmp	.+22     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_EIGHT):
		data = 8;
		NVMCTRL.DATAL = data;
     cbc:	88 e0       	ldi	r24, 0x08	; 8
     cbe:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     cc2:	07 c0       	rjmp	.+14     	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_NINE):
		data = 9;
		NVMCTRL.DATAL = data;
     cc4:	89 e0       	ldi	r24, 0x09	; 9
     cc6:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
     cca:	03 c0       	rjmp	.+6      	; 0xcd2 <EEPROM_write+0x80>
		case(BRIGHT_TEN):
		data = 10;
		NVMCTRL.DATAL = data;
     ccc:	8a e0       	ldi	r24, 0x0A	; 10
     cce:	80 93 06 10 	sts	0x1006, r24	; 0x801006 <__RODATA_PM_OFFSET__+0x7fd006>
		break;
		default:
		break;
	}
	
	NVMCTRL.DATAH = 0x00;
     cd2:	e0 e0       	ldi	r30, 0x00	; 0
     cd4:	f0 e1       	ldi	r31, 0x10	; 16
     cd6:	17 82       	std	Z+7, r1	; 0x07
	CPU_CCP = CCP_SPM_gc;
     cd8:	8d e9       	ldi	r24, 0x9D	; 157
     cda:	84 bf       	out	0x34, r24	; 52
	NVMCTRL.CTRLA = NVMCTRL_CMD_PAGEWRITE_gc;
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	80 83       	st	Z, r24
     ce0:	08 95       	ret

00000ce2 <init_CLK>:
/************************************************************************/
/* Initializes the main clock to 20MHz. We are using 0xD8 key to open MCLKLOCK,MCLKCTRLB.                                                                     */
/************************************************************************/
void init_CLK(){
	CCP = 0xD8;
     ce2:	88 ed       	ldi	r24, 0xD8	; 216
     ce4:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKLOCK =0x00;
     ce6:	e0 e6       	ldi	r30, 0x60	; 96
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	12 82       	std	Z+2, r1	; 0x02
	CCP = 0xD8;
     cec:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB = 0;
     cee:	11 82       	std	Z+1, r1	; 0x01
	CCP = 0xD8;
     cf0:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKLOCK =0x01;
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	82 83       	std	Z+2, r24	; 0x02
     cf6:	08 95       	ret

00000cf8 <init_LED>:
/************************************************************************/
/* Initializes four LEDs on the hood.                                                                     */
/************************************************************************/
void init_LED(){
	//Initialize LEDs
	PORTA.DIR = (1<<LED_1) | (1<<LED_2) | (1<<LED_3) | (1<<LED_4) ;
     cf8:	e0 e0       	ldi	r30, 0x00	; 0
     cfa:	f4 e0       	ldi	r31, 0x04	; 4
     cfc:	87 e2       	ldi	r24, 0x27	; 39
     cfe:	80 83       	st	Z, r24
	PORTA.OUT = 0xFF; // Close All LEDs
     d00:	8f ef       	ldi	r24, 0xFF	; 255
     d02:	84 83       	std	Z+4, r24	; 0x04
     d04:	08 95       	ret

00000d06 <init_Motor>:
/************************************************************************/
/* Initializes the motor relays on the hood.                                                                     */
/************************************************************************/
void init_Motor(){
	//Initialize Motors
	PORTD.DIR = (1<<MOTOR_RELAY_1) | (1<<MOTOR_RELAY_2)  |(1<<MOTOR_RELAY_3) |(1<<MOTOR_RELAY_4);
     d06:	e0 e6       	ldi	r30, 0x60	; 96
     d08:	f4 e0       	ldi	r31, 0x04	; 4
     d0a:	84 e7       	ldi	r24, 0x74	; 116
     d0c:	80 83       	st	Z, r24
	PORTD.OUT = 0x00; //Close all motors
     d0e:	14 82       	std	Z+4, r1	; 0x04
     d10:	08 95       	ret

00000d12 <init_Buzzer>:
}
/************************************************************************/
/* Initializes the buzzer.                                                                     */
/************************************************************************/
void init_Buzzer(){
		PORTD.DIR |= (1<<BUZZER);
     d12:	e0 e6       	ldi	r30, 0x60	; 96
     d14:	f4 e0       	ldi	r31, 0x04	; 4
     d16:	80 81       	ld	r24, Z
     d18:	80 68       	ori	r24, 0x80	; 128
     d1a:	80 83       	st	Z, r24
		PORTD.OUT &= ~(1<<BUZZER);
     d1c:	84 81       	ldd	r24, Z+4	; 0x04
     d1e:	8f 77       	andi	r24, 0x7F	; 127
     d20:	84 83       	std	Z+4, r24	; 0x04
     d22:	08 95       	ret

00000d24 <init_IR>:
/************************************************************************/
/* Initializes the Infrared Receiver. Interrupt is set to trigger at falling edge.                                                                     */
/************************************************************************/
void init_IR(){
	//Initialize IR Receiver
	PORTA.DIR &= ~(1<<IR_INPUT);	
     d24:	e0 e0       	ldi	r30, 0x00	; 0
     d26:	f4 e0       	ldi	r31, 0x04	; 4
     d28:	80 81       	ld	r24, Z
     d2a:	87 7f       	andi	r24, 0xF7	; 247
     d2c:	80 83       	st	Z, r24
	PORTA.PIN3CTRL |= 0b00000011; //SET ISC to 0x3 to have falling edge trigger. ISC is last 3 bits. Set to 011.
     d2e:	83 89       	ldd	r24, Z+19	; 0x13
     d30:	83 60       	ori	r24, 0x03	; 3
     d32:	83 8b       	std	Z+19, r24	; 0x13
     d34:	08 95       	ret

00000d36 <init_RTC>:
/* Initializes the RTC peripheral. We are using a 32.768kHz RTC and we set the interrupt to trigger at
every 122us. We are giving higher priority to the RTC interrupt.                                                                     */
/************************************************************************/
void init_RTC(){
	//RTC initialize
	RTC.CLKSEL = RTC_CLKSEL_INT32K_gc;//32.768 kHz RTC
     d36:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <__RODATA_PM_OFFSET__+0x7fc147>
	while (RTC.STATUS > 0);//wait until status OK
     d3a:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <__RODATA_PM_OFFSET__+0x7fc141>
     d3e:	81 11       	cpse	r24, r1
     d40:	fc cf       	rjmp	.-8      	; 0xd3a <init_RTC+0x4>
	RTC.PER = 4;  // 122 us per tick
     d42:	e0 e4       	ldi	r30, 0x40	; 64
     d44:	f1 e0       	ldi	r31, 0x01	; 1
     d46:	84 e0       	ldi	r24, 0x04	; 4
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	82 87       	std	Z+10, r24	; 0x0a
     d4c:	93 87       	std	Z+11, r25	; 0x0b
	RTC.INTCTRL |= RTC_OVF_bm;
     d4e:	82 81       	ldd	r24, Z+2	; 0x02
     d50:	81 60       	ori	r24, 0x01	; 1
     d52:	82 83       	std	Z+2, r24	; 0x02
	RTC.CTRLA = RTC_PRESCALER_DIV1_gc|RTC_RTCEN_bm | RTC_RUNSTDBY_bm;
     d54:	81 e8       	ldi	r24, 0x81	; 129
     d56:	80 83       	st	Z, r24
	CPUINT.LVL1VEC = RTC_CNT_vect_num;//Give priority to RTC Interrupt
     d58:	83 e0       	ldi	r24, 0x03	; 3
     d5a:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__RODATA_PM_OFFSET__+0x7fc113>
     d5e:	08 95       	ret

00000d60 <init_Lights>:
}
/************************************************************************/
/* Initializes the lights at the panel. These lights are controlled by a PWM output.                                                                     */
/************************************************************************/
void init_Lights(){
	PORTD.DIR = (1<<LED_ON_OFF);
     d60:	e0 e6       	ldi	r30, 0x60	; 96
     d62:	f4 e0       	ldi	r31, 0x04	; 4
     d64:	82 e0       	ldi	r24, 0x02	; 2
     d66:	80 83       	st	Z, r24
	PORTD.OUT = 0x00; // Close All LEDs
     d68:	14 82       	std	Z+4, r1	; 0x04
     d6a:	08 95       	ret

00000d6c <Initialize>:
/************************************************************************/
/* This function initializes above functions, enabling interrupts and initializes global state variables.                                                                     */
/************************************************************************/
void Initialize(){
	
	init_CLK();
     d6c:	ba df       	rcall	.-140    	; 0xce2 <init_CLK>
	init_LED();
     d6e:	c4 df       	rcall	.-120    	; 0xcf8 <init_LED>
	init_Motor();
     d70:	ca df       	rcall	.-108    	; 0xd06 <init_Motor>
	
	init_IR();
     d72:	d8 df       	rcall	.-80     	; 0xd24 <init_IR>
	init_Lights();
     d74:	f5 df       	rcall	.-22     	; 0xd60 <init_Lights>
	init_Buzzer();
     d76:	cd df       	rcall	.-102    	; 0xd12 <init_Buzzer>
	SREG |= (1<<GLOBAL_INT_ENABLE); //Enable Interrupts
     d78:	8f b7       	in	r24, 0x3f	; 63
     d7a:	80 68       	ori	r24, 0x80	; 128
     d7c:	8f bf       	out	0x3f, r24	; 63
	 /* Enable Global Interrupts */
	//Initial state
	State.currentState = OFF;
     d7e:	10 92 49 3c 	sts	0x3C49, r1	; 0x803c49 <State>
	LightState.currentState = OFF;
     d82:	10 92 44 3c 	sts	0x3C44, r1	; 0x803c44 <LightState>
	NECState.currentState = IDLE;
     d86:	10 92 4a 3c 	sts	0x3C4A, r1	; 0x803c4a <NECState>
	InputState.currentState = INITIAL_STATE;
     d8a:	88 e0       	ldi	r24, 0x08	; 8
     d8c:	80 93 45 3c 	sts	0x3C45, r24	; 0x803c45 <InputState>
	BrightModeState.currentState = ONE;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	80 93 4b 3c 	sts	0x3C4B, r24	; 0x803c4b <BrightModeState>
	PreviousBrightModeState.currentState = BrightModeState.currentState;
     d96:	80 93 4d 3c 	sts	0x3C4D, r24	; 0x803c4d <PreviousBrightModeState>
	//EEPROM_read();
	init_RTC();
     d9a:	cd df       	rcall	.-102    	; 0xd36 <init_RTC>
     d9c:	08 95       	ret

00000d9e <__vector_6>:
/************************************************************************/
/* this interrupt function triggers when the infrared signal is received by a falling edge.
After receiving the message, this interrupt is disabled for a short period of time to process incoming data,
as there are falling edges in the signal and we should not trigger the interrupt.                                                                     */
/************************************************************************/
ISR(PORTA_PORT_vect){
     d9e:	1f 92       	push	r1
     da0:	0f 92       	push	r0
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	0f 92       	push	r0
     da6:	11 24       	eor	r1, r1
     da8:	2f 93       	push	r18
     daa:	3f 93       	push	r19
     dac:	4f 93       	push	r20
     dae:	5f 93       	push	r21
     db0:	6f 93       	push	r22
     db2:	7f 93       	push	r23
     db4:	8f 93       	push	r24
     db6:	9f 93       	push	r25
     db8:	af 93       	push	r26
     dba:	bf 93       	push	r27
     dbc:	ef 93       	push	r30
     dbe:	ff 93       	push	r31
	NECState.currentState = COMMAND;
     dc0:	82 e0       	ldi	r24, 0x02	; 2
     dc2:	80 93 4a 3c 	sts	0x3C4A, r24	; 0x803c4a <NECState>
	IR_Read();
     dc6:	33 dd       	rcall	.-1434   	; 0x82e <IR_Read>
}
     dc8:	ff 91       	pop	r31
     dca:	ef 91       	pop	r30
     dcc:	bf 91       	pop	r27
     dce:	af 91       	pop	r26
     dd0:	9f 91       	pop	r25
     dd2:	8f 91       	pop	r24
     dd4:	7f 91       	pop	r23
     dd6:	6f 91       	pop	r22
     dd8:	5f 91       	pop	r21
     dda:	4f 91       	pop	r20
     ddc:	3f 91       	pop	r19
     dde:	2f 91       	pop	r18
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
     de4:	0f 90       	pop	r0
     de6:	1f 90       	pop	r1
     de8:	18 95       	reti

00000dea <__vector_3>:
/************************************************************************/
/* This interrupt is Real Time Clock (RTC) interrupt. We are given it high priority because no matter what,
we want trigger every 0.122 us. According to the different states, certain flags are opened and closed to 
change different counter variables.                                                                     */
/************************************************************************/
ISR(RTC_CNT_vect){
     dea:	1f 92       	push	r1
     dec:	0f 92       	push	r0
     dee:	0f b6       	in	r0, 0x3f	; 63
     df0:	0f 92       	push	r0
     df2:	11 24       	eor	r1, r1
     df4:	2f 93       	push	r18
     df6:	3f 93       	push	r19
     df8:	4f 93       	push	r20
     dfa:	5f 93       	push	r21
     dfc:	6f 93       	push	r22
     dfe:	7f 93       	push	r23
     e00:	8f 93       	push	r24
     e02:	9f 93       	push	r25
     e04:	af 93       	push	r26
     e06:	bf 93       	push	r27
     e08:	ef 93       	push	r30
     e0a:	ff 93       	push	r31
	RTC.INTFLAGS = RTC_OVF_bm;
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__RODATA_PM_OFFSET__+0x7fc143>
	
	if(idle_flag == 1){
     e12:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <idle_flag>
     e16:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <idle_flag+0x1>
     e1a:	01 97       	sbiw	r24, 0x01	; 1
     e1c:	99 f4       	brne	.+38     	; 0xe44 <__vector_3+0x5a>
		counter++;
     e1e:	80 91 34 3c 	lds	r24, 0x3C34	; 0x803c34 <counter>
     e22:	90 91 35 3c 	lds	r25, 0x3C35	; 0x803c35 <counter+0x1>
     e26:	a0 91 36 3c 	lds	r26, 0x3C36	; 0x803c36 <counter+0x2>
     e2a:	b0 91 37 3c 	lds	r27, 0x3C37	; 0x803c37 <counter+0x3>
     e2e:	01 96       	adiw	r24, 0x01	; 1
     e30:	a1 1d       	adc	r26, r1
     e32:	b1 1d       	adc	r27, r1
     e34:	80 93 34 3c 	sts	0x3C34, r24	; 0x803c34 <counter>
     e38:	90 93 35 3c 	sts	0x3C35, r25	; 0x803c35 <counter+0x1>
     e3c:	a0 93 36 3c 	sts	0x3C36, r26	; 0x803c36 <counter+0x2>
     e40:	b0 93 37 3c 	sts	0x3C37, r27	; 0x803c37 <counter+0x3>
	}
	if(command_counter_flag==1){
     e44:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <command_counter_flag>
     e48:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <command_counter_flag+0x1>
     e4c:	01 97       	sbiw	r24, 0x01	; 1
     e4e:	e1 f4       	brne	.+56     	; 0xe88 <__vector_3+0x9e>
		tick_counter++;
     e50:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <tick_counter>
     e54:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <tick_counter+0x1>
     e58:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <tick_counter+0x2>
     e5c:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <tick_counter+0x3>
     e60:	01 96       	adiw	r24, 0x01	; 1
     e62:	a1 1d       	adc	r26, r1
     e64:	b1 1d       	adc	r27, r1
     e66:	80 93 2c 3c 	sts	0x3C2C, r24	; 0x803c2c <tick_counter>
     e6a:	90 93 2d 3c 	sts	0x3C2D, r25	; 0x803c2d <tick_counter+0x1>
     e6e:	a0 93 2e 3c 	sts	0x3C2E, r26	; 0x803c2e <tick_counter+0x2>
     e72:	b0 93 2f 3c 	sts	0x3C2F, r27	; 0x803c2f <tick_counter+0x3>
		total_tick_counter++;
     e76:	80 91 2a 3c 	lds	r24, 0x3C2A	; 0x803c2a <total_tick_counter>
     e7a:	90 91 2b 3c 	lds	r25, 0x3C2B	; 0x803c2b <total_tick_counter+0x1>
     e7e:	01 96       	adiw	r24, 0x01	; 1
     e80:	80 93 2a 3c 	sts	0x3C2A, r24	; 0x803c2a <total_tick_counter>
     e84:	90 93 2b 3c 	sts	0x3C2B, r25	; 0x803c2b <total_tick_counter+0x1>
	}
	if(State.currentState==BOOST){
     e88:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
     e8c:	84 30       	cpi	r24, 0x04	; 4
     e8e:	09 f0       	breq	.+2      	; 0xe92 <__vector_3+0xa8>
     e90:	58 c0       	rjmp	.+176    	; 0xf42 <__vector_3+0x158>
		boost_timer++;
     e92:	80 91 1c 3c 	lds	r24, 0x3C1C	; 0x803c1c <boost_timer>
     e96:	90 91 1d 3c 	lds	r25, 0x3C1D	; 0x803c1d <boost_timer+0x1>
     e9a:	a0 91 1e 3c 	lds	r26, 0x3C1E	; 0x803c1e <boost_timer+0x2>
     e9e:	b0 91 1f 3c 	lds	r27, 0x3C1F	; 0x803c1f <boost_timer+0x3>
     ea2:	01 96       	adiw	r24, 0x01	; 1
     ea4:	a1 1d       	adc	r26, r1
     ea6:	b1 1d       	adc	r27, r1
     ea8:	80 93 1c 3c 	sts	0x3C1C, r24	; 0x803c1c <boost_timer>
     eac:	90 93 1d 3c 	sts	0x3C1D, r25	; 0x803c1d <boost_timer+0x1>
     eb0:	a0 93 1e 3c 	sts	0x3C1E, r26	; 0x803c1e <boost_timer+0x2>
     eb4:	b0 93 1f 3c 	sts	0x3C1F, r27	; 0x803c1f <boost_timer+0x3>
		boost_total_timer++;
     eb8:	80 91 18 3c 	lds	r24, 0x3C18	; 0x803c18 <boost_total_timer>
     ebc:	90 91 19 3c 	lds	r25, 0x3C19	; 0x803c19 <boost_total_timer+0x1>
     ec0:	a0 91 1a 3c 	lds	r26, 0x3C1A	; 0x803c1a <boost_total_timer+0x2>
     ec4:	b0 91 1b 3c 	lds	r27, 0x3C1B	; 0x803c1b <boost_total_timer+0x3>
     ec8:	01 96       	adiw	r24, 0x01	; 1
     eca:	a1 1d       	adc	r26, r1
     ecc:	b1 1d       	adc	r27, r1
     ece:	80 93 18 3c 	sts	0x3C18, r24	; 0x803c18 <boost_total_timer>
     ed2:	90 93 19 3c 	sts	0x3C19, r25	; 0x803c19 <boost_total_timer+0x1>
     ed6:	a0 93 1a 3c 	sts	0x3C1A, r26	; 0x803c1a <boost_total_timer+0x2>
     eda:	b0 93 1b 3c 	sts	0x3C1B, r27	; 0x803c1b <boost_total_timer+0x3>
		if(boost_timer*RTC_TICK >= ONE_SEC){ // 1sec
     ede:	20 91 1c 3c 	lds	r18, 0x3C1C	; 0x803c1c <boost_timer>
     ee2:	30 91 1d 3c 	lds	r19, 0x3C1D	; 0x803c1d <boost_timer+0x1>
     ee6:	40 91 1e 3c 	lds	r20, 0x3C1E	; 0x803c1e <boost_timer+0x2>
     eea:	50 91 1f 3c 	lds	r21, 0x3C1F	; 0x803c1f <boost_timer+0x3>
     eee:	aa e7       	ldi	r26, 0x7A	; 122
     ef0:	b0 e0       	ldi	r27, 0x00	; 0
     ef2:	70 d2       	rcall	.+1248   	; 0x13d4 <__muluhisi3>
     ef4:	60 34       	cpi	r22, 0x40	; 64
     ef6:	72 44       	sbci	r23, 0x42	; 66
     ef8:	8f 40       	sbci	r24, 0x0F	; 15
     efa:	91 05       	cpc	r25, r1
     efc:	70 f0       	brcs	.+28     	; 0xf1a <__vector_3+0x130>
			PORTA.OUT ^= (1<<LED_4);
     efe:	e0 e0       	ldi	r30, 0x00	; 0
     f00:	f4 e0       	ldi	r31, 0x04	; 4
     f02:	94 81       	ldd	r25, Z+4	; 0x04
     f04:	80 e2       	ldi	r24, 0x20	; 32
     f06:	89 27       	eor	r24, r25
     f08:	84 83       	std	Z+4, r24	; 0x04
			boost_timer=0;
     f0a:	10 92 1c 3c 	sts	0x3C1C, r1	; 0x803c1c <boost_timer>
     f0e:	10 92 1d 3c 	sts	0x3C1D, r1	; 0x803c1d <boost_timer+0x1>
     f12:	10 92 1e 3c 	sts	0x3C1E, r1	; 0x803c1e <boost_timer+0x2>
     f16:	10 92 1f 3c 	sts	0x3C1F, r1	; 0x803c1f <boost_timer+0x3>
		}
		if(boost_total_timer*RTC_TICK>=BOOST_MAX_30SEC){
     f1a:	20 91 18 3c 	lds	r18, 0x3C18	; 0x803c18 <boost_total_timer>
     f1e:	30 91 19 3c 	lds	r19, 0x3C19	; 0x803c19 <boost_total_timer+0x1>
     f22:	40 91 1a 3c 	lds	r20, 0x3C1A	; 0x803c1a <boost_total_timer+0x2>
     f26:	50 91 1b 3c 	lds	r21, 0x3C1B	; 0x803c1b <boost_total_timer+0x3>
     f2a:	aa e7       	ldi	r26, 0x7A	; 122
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	52 d2       	rcall	.+1188   	; 0x13d4 <__muluhisi3>
     f30:	60 38       	cpi	r22, 0x80	; 128
     f32:	73 4c       	sbci	r23, 0xC3	; 195
     f34:	89 4c       	sbci	r24, 0xC9	; 201
     f36:	91 40       	sbci	r25, 0x01	; 1
     f38:	20 f0       	brcs	.+8      	; 0xf42 <__vector_3+0x158>
			State.currentState = THREE;
     f3a:	83 e0       	ldi	r24, 0x03	; 3
     f3c:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
			setState();
     f40:	54 db       	rcall	.-2392   	; 0x5ea <setState>
		}
	}
	if(hold_flag==1){
     f42:	80 91 20 3c 	lds	r24, 0x3C20	; 0x803c20 <hold_flag>
     f46:	90 91 21 3c 	lds	r25, 0x3C21	; 0x803c21 <hold_flag+0x1>
     f4a:	01 97       	sbiw	r24, 0x01	; 1
     f4c:	09 f0       	breq	.+2      	; 0xf50 <__vector_3+0x166>
     f4e:	35 c1       	rjmp	.+618    	; 0x11ba <__vector_3+0x3d0>
		hold_counter++;
     f50:	80 91 22 3c 	lds	r24, 0x3C22	; 0x803c22 <hold_counter>
     f54:	90 91 23 3c 	lds	r25, 0x3C23	; 0x803c23 <hold_counter+0x1>
     f58:	a0 91 24 3c 	lds	r26, 0x3C24	; 0x803c24 <hold_counter+0x2>
     f5c:	b0 91 25 3c 	lds	r27, 0x3C25	; 0x803c25 <hold_counter+0x3>
     f60:	01 96       	adiw	r24, 0x01	; 1
     f62:	a1 1d       	adc	r26, r1
     f64:	b1 1d       	adc	r27, r1
     f66:	80 93 22 3c 	sts	0x3C22, r24	; 0x803c22 <hold_counter>
     f6a:	90 93 23 3c 	sts	0x3C23, r25	; 0x803c23 <hold_counter+0x1>
     f6e:	a0 93 24 3c 	sts	0x3C24, r26	; 0x803c24 <hold_counter+0x2>
     f72:	b0 93 25 3c 	sts	0x3C25, r27	; 0x803c25 <hold_counter+0x3>
		if((hold_counter*RTC_TICK>=2*ONE_SEC) && InputState.currentState==POWER_HOLD){//After 4 sec power button press, indicate with buzzer and wait for 2 sec
     f76:	20 91 22 3c 	lds	r18, 0x3C22	; 0x803c22 <hold_counter>
     f7a:	30 91 23 3c 	lds	r19, 0x3C23	; 0x803c23 <hold_counter+0x1>
     f7e:	40 91 24 3c 	lds	r20, 0x3C24	; 0x803c24 <hold_counter+0x2>
     f82:	50 91 25 3c 	lds	r21, 0x3C25	; 0x803c25 <hold_counter+0x3>
     f86:	aa e7       	ldi	r26, 0x7A	; 122
     f88:	b0 e0       	ldi	r27, 0x00	; 0
     f8a:	24 d2       	rcall	.+1096   	; 0x13d4 <__muluhisi3>
     f8c:	60 38       	cpi	r22, 0x80	; 128
     f8e:	74 48       	sbci	r23, 0x84	; 132
     f90:	8e 41       	sbci	r24, 0x1E	; 30
     f92:	91 05       	cpc	r25, r1
     f94:	e0 f0       	brcs	.+56     	; 0xfce <__vector_3+0x1e4>
     f96:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
     f9a:	81 30       	cpi	r24, 0x01	; 1
     f9c:	c1 f4       	brne	.+48     	; 0xfce <__vector_3+0x1e4>
			dev_mode_flag=1;
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	a0 e0       	ldi	r26, 0x00	; 0
     fa4:	b0 e0       	ldi	r27, 0x00	; 0
     fa6:	80 93 14 3c 	sts	0x3C14, r24	; 0x803c14 <dev_mode_flag>
     faa:	90 93 15 3c 	sts	0x3C15, r25	; 0x803c15 <dev_mode_flag+0x1>
     fae:	a0 93 16 3c 	sts	0x3C16, r26	; 0x803c16 <dev_mode_flag+0x2>
     fb2:	b0 93 17 3c 	sts	0x3C17, r27	; 0x803c17 <dev_mode_flag+0x3>
			BuzzerState.currentState = DEV_INIT_SOUND;
     fb6:	85 e0       	ldi	r24, 0x05	; 5
     fb8:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
     fbc:	af d8       	rcall	.-3746   	; 0x11c <Buzzer>
			hold_counter=0;
     fbe:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <hold_counter>
     fc2:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <hold_counter+0x1>
     fc6:	10 92 24 3c 	sts	0x3C24, r1	; 0x803c24 <hold_counter+0x2>
     fca:	10 92 25 3c 	sts	0x3C25, r1	; 0x803c25 <hold_counter+0x3>
			
		}
		if((hold_counter*RTC_TICK>=2*ONE_SEC)&&InputState.currentState== LIGHT_HOLD&&dev_mode_flag==0&&bright_mode_flag==0){
     fce:	20 91 22 3c 	lds	r18, 0x3C22	; 0x803c22 <hold_counter>
     fd2:	30 91 23 3c 	lds	r19, 0x3C23	; 0x803c23 <hold_counter+0x1>
     fd6:	40 91 24 3c 	lds	r20, 0x3C24	; 0x803c24 <hold_counter+0x2>
     fda:	50 91 25 3c 	lds	r21, 0x3C25	; 0x803c25 <hold_counter+0x3>
     fde:	aa e7       	ldi	r26, 0x7A	; 122
     fe0:	b0 e0       	ldi	r27, 0x00	; 0
     fe2:	f8 d1       	rcall	.+1008   	; 0x13d4 <__muluhisi3>
     fe4:	60 38       	cpi	r22, 0x80	; 128
     fe6:	74 48       	sbci	r23, 0x84	; 132
     fe8:	8e 41       	sbci	r24, 0x1E	; 30
     fea:	91 05       	cpc	r25, r1
     fec:	c0 f1       	brcs	.+112    	; 0x105e <__vector_3+0x274>
     fee:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
     ff2:	87 30       	cpi	r24, 0x07	; 7
     ff4:	a1 f5       	brne	.+104    	; 0x105e <__vector_3+0x274>
     ff6:	80 91 14 3c 	lds	r24, 0x3C14	; 0x803c14 <dev_mode_flag>
     ffa:	90 91 15 3c 	lds	r25, 0x3C15	; 0x803c15 <dev_mode_flag+0x1>
     ffe:	a0 91 16 3c 	lds	r26, 0x3C16	; 0x803c16 <dev_mode_flag+0x2>
    1002:	b0 91 17 3c 	lds	r27, 0x3C17	; 0x803c17 <dev_mode_flag+0x3>
    1006:	89 2b       	or	r24, r25
    1008:	8a 2b       	or	r24, r26
    100a:	8b 2b       	or	r24, r27
    100c:	41 f5       	brne	.+80     	; 0x105e <__vector_3+0x274>
    100e:	80 91 08 3c 	lds	r24, 0x3C08	; 0x803c08 <bright_mode_flag>
    1012:	90 91 09 3c 	lds	r25, 0x3C09	; 0x803c09 <bright_mode_flag+0x1>
    1016:	a0 91 0a 3c 	lds	r26, 0x3C0A	; 0x803c0a <bright_mode_flag+0x2>
    101a:	b0 91 0b 3c 	lds	r27, 0x3C0B	; 0x803c0b <bright_mode_flag+0x3>
    101e:	89 2b       	or	r24, r25
    1020:	8a 2b       	or	r24, r26
    1022:	8b 2b       	or	r24, r27
    1024:	e1 f4       	brne	.+56     	; 0x105e <__vector_3+0x274>
			State.currentState = BRIGHT_ADJ;
    1026:	86 e0       	ldi	r24, 0x06	; 6
    1028:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
			bright_mode_flag=1;
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	a0 e0       	ldi	r26, 0x00	; 0
    1032:	b0 e0       	ldi	r27, 0x00	; 0
    1034:	80 93 08 3c 	sts	0x3C08, r24	; 0x803c08 <bright_mode_flag>
    1038:	90 93 09 3c 	sts	0x3C09, r25	; 0x803c09 <bright_mode_flag+0x1>
    103c:	a0 93 0a 3c 	sts	0x3C0A, r26	; 0x803c0a <bright_mode_flag+0x2>
    1040:	b0 93 0b 3c 	sts	0x3C0B, r27	; 0x803c0b <bright_mode_flag+0x3>
			BuzzerState.currentState = LIGHT_ADJ_SOUND;
    1044:	87 e0       	ldi	r24, 0x07	; 7
    1046:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
    104a:	68 d8       	rcall	.-3888   	; 0x11c <Buzzer>
			setState();
    104c:	ce da       	rcall	.-2660   	; 0x5ea <setState>
			hold_counter=0;
    104e:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <hold_counter>
    1052:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <hold_counter+0x1>
    1056:	10 92 24 3c 	sts	0x3C24, r1	; 0x803c24 <hold_counter+0x2>
    105a:	10 92 25 3c 	sts	0x3C25, r1	; 0x803c25 <hold_counter+0x3>
		}
		if((hold_counter*RTC_TICK>=2*ONE_SEC)&&InputState.currentState== LIGHT_HOLD&&dev_mode_flag==0&&bright_mode_flag==1){
    105e:	20 91 22 3c 	lds	r18, 0x3C22	; 0x803c22 <hold_counter>
    1062:	30 91 23 3c 	lds	r19, 0x3C23	; 0x803c23 <hold_counter+0x1>
    1066:	40 91 24 3c 	lds	r20, 0x3C24	; 0x803c24 <hold_counter+0x2>
    106a:	50 91 25 3c 	lds	r21, 0x3C25	; 0x803c25 <hold_counter+0x3>
    106e:	aa e7       	ldi	r26, 0x7A	; 122
    1070:	b0 e0       	ldi	r27, 0x00	; 0
    1072:	b0 d1       	rcall	.+864    	; 0x13d4 <__muluhisi3>
    1074:	60 38       	cpi	r22, 0x80	; 128
    1076:	74 48       	sbci	r23, 0x84	; 132
    1078:	8e 41       	sbci	r24, 0x1E	; 30
    107a:	91 05       	cpc	r25, r1
    107c:	08 f4       	brcc	.+2      	; 0x1080 <__vector_3+0x296>
    107e:	6d c0       	rjmp	.+218    	; 0x115a <__vector_3+0x370>
    1080:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
    1084:	87 30       	cpi	r24, 0x07	; 7
    1086:	09 f0       	breq	.+2      	; 0x108a <__vector_3+0x2a0>
    1088:	68 c0       	rjmp	.+208    	; 0x115a <__vector_3+0x370>
    108a:	80 91 14 3c 	lds	r24, 0x3C14	; 0x803c14 <dev_mode_flag>
    108e:	90 91 15 3c 	lds	r25, 0x3C15	; 0x803c15 <dev_mode_flag+0x1>
    1092:	a0 91 16 3c 	lds	r26, 0x3C16	; 0x803c16 <dev_mode_flag+0x2>
    1096:	b0 91 17 3c 	lds	r27, 0x3C17	; 0x803c17 <dev_mode_flag+0x3>
    109a:	89 2b       	or	r24, r25
    109c:	8a 2b       	or	r24, r26
    109e:	8b 2b       	or	r24, r27
    10a0:	09 f0       	breq	.+2      	; 0x10a4 <__vector_3+0x2ba>
    10a2:	5b c0       	rjmp	.+182    	; 0x115a <__vector_3+0x370>
    10a4:	80 91 08 3c 	lds	r24, 0x3C08	; 0x803c08 <bright_mode_flag>
    10a8:	90 91 09 3c 	lds	r25, 0x3C09	; 0x803c09 <bright_mode_flag+0x1>
    10ac:	a0 91 0a 3c 	lds	r26, 0x3C0A	; 0x803c0a <bright_mode_flag+0x2>
    10b0:	b0 91 0b 3c 	lds	r27, 0x3C0B	; 0x803c0b <bright_mode_flag+0x3>
    10b4:	01 97       	sbiw	r24, 0x01	; 1
    10b6:	a1 05       	cpc	r26, r1
    10b8:	b1 05       	cpc	r27, r1
    10ba:	09 f0       	breq	.+2      	; 0x10be <__vector_3+0x2d4>
    10bc:	4e c0       	rjmp	.+156    	; 0x115a <__vector_3+0x370>
			State.currentState = ONE;
    10be:	81 e0       	ldi	r24, 0x01	; 1
    10c0:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
			setState();
    10c4:	92 da       	rcall	.-2780   	; 0x5ea <setState>
			bright_mode_flag=0;
    10c6:	10 92 08 3c 	sts	0x3C08, r1	; 0x803c08 <bright_mode_flag>
    10ca:	10 92 09 3c 	sts	0x3C09, r1	; 0x803c09 <bright_mode_flag+0x1>
    10ce:	10 92 0a 3c 	sts	0x3C0A, r1	; 0x803c0a <bright_mode_flag+0x2>
    10d2:	10 92 0b 3c 	sts	0x3C0B, r1	; 0x803c0b <bright_mode_flag+0x3>
			BuzzerState.currentState = LIGHT_ADJ_SOUND;
    10d6:	87 e0       	ldi	r24, 0x07	; 7
    10d8:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
    10dc:	1f d8       	rcall	.-4034   	; 0x11c <Buzzer>
			hold_counter=0;
    10de:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <hold_counter>
    10e2:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <hold_counter+0x1>
    10e6:	10 92 24 3c 	sts	0x3C24, r1	; 0x803c24 <hold_counter+0x2>
    10ea:	10 92 25 3c 	sts	0x3C25, r1	; 0x803c25 <hold_counter+0x3>
			EEPROM_write(BrightModeState);
    10ee:	80 91 4b 3c 	lds	r24, 0x3C4B	; 0x803c4b <BrightModeState>
    10f2:	af dd       	rcall	.-1186   	; 0xc52 <EEPROM_write>
			bright_level=EEPROM_read();
    10f4:	a3 dd       	rcall	.-1210   	; 0xc3c <EEPROM_read>
    10f6:	20 93 00 3c 	sts	0x3C00, r18	; 0x803c00 <__DATA_REGION_ORIGIN__>
    10fa:	30 93 01 3c 	sts	0x3C01, r19	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
    10fe:	40 93 02 3c 	sts	0x3C02, r20	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
    1102:	50 93 03 3c 	sts	0x3C03, r21	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
    1106:	60 93 04 3c 	sts	0x3C04, r22	; 0x803c04 <__DATA_REGION_ORIGIN__+0x4>
    110a:	70 93 05 3c 	sts	0x3C05, r23	; 0x803c05 <__DATA_REGION_ORIGIN__+0x5>
    110e:	80 93 06 3c 	sts	0x3C06, r24	; 0x803c06 <__DATA_REGION_ORIGIN__+0x6>
    1112:	90 93 07 3c 	sts	0x3C07, r25	; 0x803c07 <__DATA_REGION_ORIGIN__+0x7>
			bright_level++;
    1116:	20 91 00 3c 	lds	r18, 0x3C00	; 0x803c00 <__DATA_REGION_ORIGIN__>
    111a:	30 91 01 3c 	lds	r19, 0x3C01	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
    111e:	40 91 02 3c 	lds	r20, 0x3C02	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
    1122:	50 91 03 3c 	lds	r21, 0x3C03	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
    1126:	60 91 04 3c 	lds	r22, 0x3C04	; 0x803c04 <__DATA_REGION_ORIGIN__+0x4>
    112a:	70 91 05 3c 	lds	r23, 0x3C05	; 0x803c05 <__DATA_REGION_ORIGIN__+0x5>
    112e:	80 91 06 3c 	lds	r24, 0x3C06	; 0x803c06 <__DATA_REGION_ORIGIN__+0x6>
    1132:	90 91 07 3c 	lds	r25, 0x3C07	; 0x803c07 <__DATA_REGION_ORIGIN__+0x7>
    1136:	a1 e0       	ldi	r26, 0x01	; 1
    1138:	57 d1       	rcall	.+686    	; 0x13e8 <__adddi3_s8>
    113a:	20 93 00 3c 	sts	0x3C00, r18	; 0x803c00 <__DATA_REGION_ORIGIN__>
    113e:	30 93 01 3c 	sts	0x3C01, r19	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
    1142:	40 93 02 3c 	sts	0x3C02, r20	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
    1146:	50 93 03 3c 	sts	0x3C03, r21	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
    114a:	60 93 04 3c 	sts	0x3C04, r22	; 0x803c04 <__DATA_REGION_ORIGIN__+0x4>
    114e:	70 93 05 3c 	sts	0x3C05, r23	; 0x803c05 <__DATA_REGION_ORIGIN__+0x5>
    1152:	80 93 06 3c 	sts	0x3C06, r24	; 0x803c06 <__DATA_REGION_ORIGIN__+0x6>
    1156:	90 93 07 3c 	sts	0x3C07, r25	; 0x803c07 <__DATA_REGION_ORIGIN__+0x7>
		}
		if((hold_counter*RTC_TICK>=1*ONE_SEC)&&InputState.currentState== LIGHT_HOLD&&dev_mode_flag==1){
    115a:	20 91 22 3c 	lds	r18, 0x3C22	; 0x803c22 <hold_counter>
    115e:	30 91 23 3c 	lds	r19, 0x3C23	; 0x803c23 <hold_counter+0x1>
    1162:	40 91 24 3c 	lds	r20, 0x3C24	; 0x803c24 <hold_counter+0x2>
    1166:	50 91 25 3c 	lds	r21, 0x3C25	; 0x803c25 <hold_counter+0x3>
    116a:	aa e7       	ldi	r26, 0x7A	; 122
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	32 d1       	rcall	.+612    	; 0x13d4 <__muluhisi3>
    1170:	60 34       	cpi	r22, 0x40	; 64
    1172:	72 44       	sbci	r23, 0x42	; 66
    1174:	8f 40       	sbci	r24, 0x0F	; 15
    1176:	91 05       	cpc	r25, r1
    1178:	00 f1       	brcs	.+64     	; 0x11ba <__vector_3+0x3d0>
    117a:	80 91 45 3c 	lds	r24, 0x3C45	; 0x803c45 <InputState>
    117e:	87 30       	cpi	r24, 0x07	; 7
    1180:	e1 f4       	brne	.+56     	; 0x11ba <__vector_3+0x3d0>
    1182:	80 91 14 3c 	lds	r24, 0x3C14	; 0x803c14 <dev_mode_flag>
    1186:	90 91 15 3c 	lds	r25, 0x3C15	; 0x803c15 <dev_mode_flag+0x1>
    118a:	a0 91 16 3c 	lds	r26, 0x3C16	; 0x803c16 <dev_mode_flag+0x2>
    118e:	b0 91 17 3c 	lds	r27, 0x3C17	; 0x803c17 <dev_mode_flag+0x3>
    1192:	01 97       	sbiw	r24, 0x01	; 1
    1194:	a1 05       	cpc	r26, r1
    1196:	b1 05       	cpc	r27, r1
    1198:	81 f4       	brne	.+32     	; 0x11ba <__vector_3+0x3d0>
			State.currentState = DEV_MODE;
    119a:	85 e0       	ldi	r24, 0x05	; 5
    119c:	80 93 49 3c 	sts	0x3C49, r24	; 0x803c49 <State>
			BuzzerState.currentState = DEV_MODE_SOUND;
    11a0:	86 e0       	ldi	r24, 0x06	; 6
    11a2:	80 93 4e 3c 	sts	0x3C4E, r24	; 0x803c4e <BuzzerState>
			Buzzer();
    11a6:	ba d7       	rcall	.+3956   	; 0x211c <__TEXT_REGION_LENGTH__+0x11c>
			dev_mode_flag=0;
    11a8:	10 92 14 3c 	sts	0x3C14, r1	; 0x803c14 <dev_mode_flag>
    11ac:	10 92 15 3c 	sts	0x3C15, r1	; 0x803c15 <dev_mode_flag+0x1>
    11b0:	10 92 16 3c 	sts	0x3C16, r1	; 0x803c16 <dev_mode_flag+0x2>
    11b4:	10 92 17 3c 	sts	0x3C17, r1	; 0x803c17 <dev_mode_flag+0x3>
			//Close all lights at first;
			setState();
    11b8:	18 da       	rcall	.-3024   	; 0x5ea <setState>
		}
	}
	if(BuzzerFlag==1){
    11ba:	80 91 40 3c 	lds	r24, 0x3C40	; 0x803c40 <BuzzerFlag>
    11be:	90 91 41 3c 	lds	r25, 0x3C41	; 0x803c41 <BuzzerFlag+0x1>
    11c2:	a0 91 42 3c 	lds	r26, 0x3C42	; 0x803c42 <BuzzerFlag+0x2>
    11c6:	b0 91 43 3c 	lds	r27, 0x3C43	; 0x803c43 <BuzzerFlag+0x3>
    11ca:	01 97       	sbiw	r24, 0x01	; 1
    11cc:	a1 05       	cpc	r26, r1
    11ce:	b1 05       	cpc	r27, r1
    11d0:	09 f0       	breq	.+2      	; 0x11d4 <__vector_3+0x3ea>
    11d2:	62 c0       	rjmp	.+196    	; 0x1298 <__vector_3+0x4ae>
		BuzzerCounter++;
    11d4:	80 91 3c 3c 	lds	r24, 0x3C3C	; 0x803c3c <BuzzerCounter>
    11d8:	90 91 3d 3c 	lds	r25, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
    11dc:	a0 91 3e 3c 	lds	r26, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
    11e0:	b0 91 3f 3c 	lds	r27, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
    11e4:	01 96       	adiw	r24, 0x01	; 1
    11e6:	a1 1d       	adc	r26, r1
    11e8:	b1 1d       	adc	r27, r1
    11ea:	80 93 3c 3c 	sts	0x3C3C, r24	; 0x803c3c <BuzzerCounter>
    11ee:	90 93 3d 3c 	sts	0x3C3D, r25	; 0x803c3d <BuzzerCounter+0x1>
    11f2:	a0 93 3e 3c 	sts	0x3C3E, r26	; 0x803c3e <BuzzerCounter+0x2>
    11f6:	b0 93 3f 3c 	sts	0x3C3F, r27	; 0x803c3f <BuzzerCounter+0x3>
		PORTD.OUT |= (1<<BUZZER);
    11fa:	e0 e6       	ldi	r30, 0x60	; 96
    11fc:	f4 e0       	ldi	r31, 0x04	; 4
    11fe:	84 81       	ldd	r24, Z+4	; 0x04
    1200:	80 68       	ori	r24, 0x80	; 128
    1202:	84 83       	std	Z+4, r24	; 0x04
		Buzzer();
    1204:	8b d7       	rcall	.+3862   	; 0x211c <__TEXT_REGION_LENGTH__+0x11c>
		
		if(BuzzerCounter*RTC_TICK>=ONE_SEC/10){
    1206:	20 91 3c 3c 	lds	r18, 0x3C3C	; 0x803c3c <BuzzerCounter>
    120a:	30 91 3d 3c 	lds	r19, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
    120e:	40 91 3e 3c 	lds	r20, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
    1212:	50 91 3f 3c 	lds	r21, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
    1216:	aa e7       	ldi	r26, 0x7A	; 122
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	dc d0       	rcall	.+440    	; 0x13d4 <__muluhisi3>
    121c:	60 3a       	cpi	r22, 0xA0	; 160
    121e:	76 48       	sbci	r23, 0x86	; 134
    1220:	81 40       	sbci	r24, 0x01	; 1
    1222:	91 05       	cpc	r25, r1
    1224:	e8 f0       	brcs	.+58     	; 0x1260 <__vector_3+0x476>
			BuzzerFlag=0;
    1226:	10 92 40 3c 	sts	0x3C40, r1	; 0x803c40 <BuzzerFlag>
    122a:	10 92 41 3c 	sts	0x3C41, r1	; 0x803c41 <BuzzerFlag+0x1>
    122e:	10 92 42 3c 	sts	0x3C42, r1	; 0x803c42 <BuzzerFlag+0x2>
    1232:	10 92 43 3c 	sts	0x3C43, r1	; 0x803c43 <BuzzerFlag+0x3>
			BuzzerCounter=0;
    1236:	10 92 3c 3c 	sts	0x3C3C, r1	; 0x803c3c <BuzzerCounter>
    123a:	10 92 3d 3c 	sts	0x3C3D, r1	; 0x803c3d <BuzzerCounter+0x1>
    123e:	10 92 3e 3c 	sts	0x3C3E, r1	; 0x803c3e <BuzzerCounter+0x2>
    1242:	10 92 3f 3c 	sts	0x3C3F, r1	; 0x803c3f <BuzzerCounter+0x3>
			Pitch_flag=0;
    1246:	10 92 38 3c 	sts	0x3C38, r1	; 0x803c38 <Pitch_flag>
    124a:	10 92 39 3c 	sts	0x3C39, r1	; 0x803c39 <Pitch_flag+0x1>
    124e:	10 92 3a 3c 	sts	0x3C3A, r1	; 0x803c3a <Pitch_flag+0x2>
    1252:	10 92 3b 3c 	sts	0x3C3B, r1	; 0x803c3b <Pitch_flag+0x3>
			PORTD.OUT &= ~(1<<BUZZER);
    1256:	e0 e6       	ldi	r30, 0x60	; 96
    1258:	f4 e0       	ldi	r31, 0x04	; 4
    125a:	84 81       	ldd	r24, Z+4	; 0x04
    125c:	8f 77       	andi	r24, 0x7F	; 127
    125e:	84 83       	std	Z+4, r24	; 0x04
		}
		if(BuzzerCounter*RTC_TICK>=ONE_SEC/20){
    1260:	20 91 3c 3c 	lds	r18, 0x3C3C	; 0x803c3c <BuzzerCounter>
    1264:	30 91 3d 3c 	lds	r19, 0x3C3D	; 0x803c3d <BuzzerCounter+0x1>
    1268:	40 91 3e 3c 	lds	r20, 0x3C3E	; 0x803c3e <BuzzerCounter+0x2>
    126c:	50 91 3f 3c 	lds	r21, 0x3C3F	; 0x803c3f <BuzzerCounter+0x3>
    1270:	aa e7       	ldi	r26, 0x7A	; 122
    1272:	b0 e0       	ldi	r27, 0x00	; 0
    1274:	af d0       	rcall	.+350    	; 0x13d4 <__muluhisi3>
    1276:	60 35       	cpi	r22, 0x50	; 80
    1278:	73 4c       	sbci	r23, 0xC3	; 195
    127a:	81 05       	cpc	r24, r1
    127c:	91 05       	cpc	r25, r1
    127e:	60 f0       	brcs	.+24     	; 0x1298 <__vector_3+0x4ae>
			Pitch_flag=1;
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	a0 e0       	ldi	r26, 0x00	; 0
    1286:	b0 e0       	ldi	r27, 0x00	; 0
    1288:	80 93 38 3c 	sts	0x3C38, r24	; 0x803c38 <Pitch_flag>
    128c:	90 93 39 3c 	sts	0x3C39, r25	; 0x803c39 <Pitch_flag+0x1>
    1290:	a0 93 3a 3c 	sts	0x3C3A, r26	; 0x803c3a <Pitch_flag+0x2>
    1294:	b0 93 3b 3c 	sts	0x3C3B, r27	; 0x803c3b <Pitch_flag+0x3>
		}
	}
	if(State.currentState==DEV_MODE){
    1298:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
    129c:	85 30       	cpi	r24, 0x05	; 5
    129e:	61 f5       	brne	.+88     	; 0x12f8 <__vector_3+0x50e>
		dev_mode_timer++;
    12a0:	80 91 10 3c 	lds	r24, 0x3C10	; 0x803c10 <dev_mode_timer>
    12a4:	90 91 11 3c 	lds	r25, 0x3C11	; 0x803c11 <dev_mode_timer+0x1>
    12a8:	a0 91 12 3c 	lds	r26, 0x3C12	; 0x803c12 <dev_mode_timer+0x2>
    12ac:	b0 91 13 3c 	lds	r27, 0x3C13	; 0x803c13 <dev_mode_timer+0x3>
    12b0:	01 96       	adiw	r24, 0x01	; 1
    12b2:	a1 1d       	adc	r26, r1
    12b4:	b1 1d       	adc	r27, r1
    12b6:	80 93 10 3c 	sts	0x3C10, r24	; 0x803c10 <dev_mode_timer>
    12ba:	90 93 11 3c 	sts	0x3C11, r25	; 0x803c11 <dev_mode_timer+0x1>
    12be:	a0 93 12 3c 	sts	0x3C12, r26	; 0x803c12 <dev_mode_timer+0x2>
    12c2:	b0 93 13 3c 	sts	0x3C13, r27	; 0x803c13 <dev_mode_timer+0x3>
		if(dev_mode_timer*RTC_TICK>=ONE_SEC){
    12c6:	20 91 10 3c 	lds	r18, 0x3C10	; 0x803c10 <dev_mode_timer>
    12ca:	30 91 11 3c 	lds	r19, 0x3C11	; 0x803c11 <dev_mode_timer+0x1>
    12ce:	40 91 12 3c 	lds	r20, 0x3C12	; 0x803c12 <dev_mode_timer+0x2>
    12d2:	50 91 13 3c 	lds	r21, 0x3C13	; 0x803c13 <dev_mode_timer+0x3>
    12d6:	aa e7       	ldi	r26, 0x7A	; 122
    12d8:	b0 e0       	ldi	r27, 0x00	; 0
    12da:	7c d0       	rcall	.+248    	; 0x13d4 <__muluhisi3>
    12dc:	60 34       	cpi	r22, 0x40	; 64
    12de:	72 44       	sbci	r23, 0x42	; 66
    12e0:	8f 40       	sbci	r24, 0x0F	; 15
    12e2:	91 05       	cpc	r25, r1
    12e4:	48 f0       	brcs	.+18     	; 0x12f8 <__vector_3+0x50e>
			dev_mode_timer=0;
    12e6:	10 92 10 3c 	sts	0x3C10, r1	; 0x803c10 <dev_mode_timer>
    12ea:	10 92 11 3c 	sts	0x3C11, r1	; 0x803c11 <dev_mode_timer+0x1>
    12ee:	10 92 12 3c 	sts	0x3C12, r1	; 0x803c12 <dev_mode_timer+0x2>
    12f2:	10 92 13 3c 	sts	0x3C13, r1	; 0x803c13 <dev_mode_timer+0x3>
			setState();
    12f6:	79 d9       	rcall	.-3342   	; 0x5ea <setState>
		}
	}
	if(State.currentState==BRIGHT_ADJ){
    12f8:	80 91 49 3c 	lds	r24, 0x3C49	; 0x803c49 <State>
    12fc:	86 30       	cpi	r24, 0x06	; 6
    12fe:	39 f5       	brne	.+78     	; 0x134e <__vector_3+0x564>
		bright_mode_counter++;
    1300:	80 91 0c 3c 	lds	r24, 0x3C0C	; 0x803c0c <bright_mode_counter>
    1304:	90 91 0d 3c 	lds	r25, 0x3C0D	; 0x803c0d <bright_mode_counter+0x1>
    1308:	a0 91 0e 3c 	lds	r26, 0x3C0E	; 0x803c0e <bright_mode_counter+0x2>
    130c:	b0 91 0f 3c 	lds	r27, 0x3C0F	; 0x803c0f <bright_mode_counter+0x3>
    1310:	01 96       	adiw	r24, 0x01	; 1
    1312:	a1 1d       	adc	r26, r1
    1314:	b1 1d       	adc	r27, r1
    1316:	80 93 0c 3c 	sts	0x3C0C, r24	; 0x803c0c <bright_mode_counter>
    131a:	90 93 0d 3c 	sts	0x3C0D, r25	; 0x803c0d <bright_mode_counter+0x1>
    131e:	a0 93 0e 3c 	sts	0x3C0E, r26	; 0x803c0e <bright_mode_counter+0x2>
    1322:	b0 93 0f 3c 	sts	0x3C0F, r27	; 0x803c0f <bright_mode_counter+0x3>
		if(bright_mode_counter==10){
    1326:	80 91 0c 3c 	lds	r24, 0x3C0C	; 0x803c0c <bright_mode_counter>
    132a:	90 91 0d 3c 	lds	r25, 0x3C0D	; 0x803c0d <bright_mode_counter+0x1>
    132e:	a0 91 0e 3c 	lds	r26, 0x3C0E	; 0x803c0e <bright_mode_counter+0x2>
    1332:	b0 91 0f 3c 	lds	r27, 0x3C0F	; 0x803c0f <bright_mode_counter+0x3>
    1336:	0a 97       	sbiw	r24, 0x0a	; 10
    1338:	a1 05       	cpc	r26, r1
    133a:	b1 05       	cpc	r27, r1
    133c:	41 f4       	brne	.+16     	; 0x134e <__vector_3+0x564>
			bright_mode_counter = 0;
    133e:	10 92 0c 3c 	sts	0x3C0C, r1	; 0x803c0c <bright_mode_counter>
    1342:	10 92 0d 3c 	sts	0x3C0D, r1	; 0x803c0d <bright_mode_counter+0x1>
    1346:	10 92 0e 3c 	sts	0x3C0E, r1	; 0x803c0e <bright_mode_counter+0x2>
    134a:	10 92 0f 3c 	sts	0x3C0F, r1	; 0x803c0f <bright_mode_counter+0x3>
		}
	}
}
    134e:	ff 91       	pop	r31
    1350:	ef 91       	pop	r30
    1352:	bf 91       	pop	r27
    1354:	af 91       	pop	r26
    1356:	9f 91       	pop	r25
    1358:	8f 91       	pop	r24
    135a:	7f 91       	pop	r23
    135c:	6f 91       	pop	r22
    135e:	5f 91       	pop	r21
    1360:	4f 91       	pop	r20
    1362:	3f 91       	pop	r19
    1364:	2f 91       	pop	r18
    1366:	0f 90       	pop	r0
    1368:	0f be       	out	0x3f, r0	; 63
    136a:	0f 90       	pop	r0
    136c:	1f 90       	pop	r1
    136e:	18 95       	reti

00001370 <__vector_19>:

/************************************************************************/
/* This interrupt function is triggered when we want to send data using USART.                                                                     */
/************************************************************************/
ISR(USART0_TXC_vect){
    1370:	1f 92       	push	r1
    1372:	0f 92       	push	r0
    1374:	0f b6       	in	r0, 0x3f	; 63
    1376:	0f 92       	push	r0
    1378:	11 24       	eor	r1, r1
	
}
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	0f 90       	pop	r0
    1380:	1f 90       	pop	r1
    1382:	18 95       	reti

00001384 <__vector_17>:
/************************************************************************/
/* This interrupt function is triggered when we receive a message from USART interface.                                                                     */
/************************************************************************/
ISR(USART0_RXC_vect){
    1384:	1f 92       	push	r1
    1386:	0f 92       	push	r0
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	0f 92       	push	r0
    138c:	11 24       	eor	r1, r1
	
}
    138e:	0f 90       	pop	r0
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	0f 90       	pop	r0
    1394:	1f 90       	pop	r1
    1396:	18 95       	reti

00001398 <main>:
//Hold that value inside of the chip, maybe write it on EEPROM or ROM


int main(void)
{
	Initialize();
    1398:	e9 dc       	rcall	.-1582   	; 0xd6c <Initialize>
    139a:	ff cf       	rjmp	.-2      	; 0x139a <main+0x2>

0000139c <__divmodsi4>:
    139c:	05 2e       	mov	r0, r21
    139e:	97 fb       	bst	r25, 7
    13a0:	16 f4       	brtc	.+4      	; 0x13a6 <__divmodsi4+0xa>
    13a2:	00 94       	com	r0
    13a4:	0f d0       	rcall	.+30     	; 0x13c4 <__negsi2>
    13a6:	57 fd       	sbrc	r21, 7
    13a8:	05 d0       	rcall	.+10     	; 0x13b4 <__divmodsi4_neg2>
    13aa:	2a d0       	rcall	.+84     	; 0x1400 <__udivmodsi4>
    13ac:	07 fc       	sbrc	r0, 7
    13ae:	02 d0       	rcall	.+4      	; 0x13b4 <__divmodsi4_neg2>
    13b0:	46 f4       	brtc	.+16     	; 0x13c2 <__divmodsi4_exit>
    13b2:	08 c0       	rjmp	.+16     	; 0x13c4 <__negsi2>

000013b4 <__divmodsi4_neg2>:
    13b4:	50 95       	com	r21
    13b6:	40 95       	com	r20
    13b8:	30 95       	com	r19
    13ba:	21 95       	neg	r18
    13bc:	3f 4f       	sbci	r19, 0xFF	; 255
    13be:	4f 4f       	sbci	r20, 0xFF	; 255
    13c0:	5f 4f       	sbci	r21, 0xFF	; 255

000013c2 <__divmodsi4_exit>:
    13c2:	08 95       	ret

000013c4 <__negsi2>:
    13c4:	90 95       	com	r25
    13c6:	80 95       	com	r24
    13c8:	70 95       	com	r23
    13ca:	61 95       	neg	r22
    13cc:	7f 4f       	sbci	r23, 0xFF	; 255
    13ce:	8f 4f       	sbci	r24, 0xFF	; 255
    13d0:	9f 4f       	sbci	r25, 0xFF	; 255
    13d2:	08 95       	ret

000013d4 <__muluhisi3>:
    13d4:	37 d0       	rcall	.+110    	; 0x1444 <__umulhisi3>
    13d6:	a5 9f       	mul	r26, r21
    13d8:	90 0d       	add	r25, r0
    13da:	b4 9f       	mul	r27, r20
    13dc:	90 0d       	add	r25, r0
    13de:	a4 9f       	mul	r26, r20
    13e0:	80 0d       	add	r24, r0
    13e2:	91 1d       	adc	r25, r1
    13e4:	11 24       	eor	r1, r1
    13e6:	08 95       	ret

000013e8 <__adddi3_s8>:
    13e8:	00 24       	eor	r0, r0
    13ea:	a7 fd       	sbrc	r26, 7
    13ec:	00 94       	com	r0
    13ee:	2a 0f       	add	r18, r26
    13f0:	30 1d       	adc	r19, r0
    13f2:	40 1d       	adc	r20, r0
    13f4:	50 1d       	adc	r21, r0
    13f6:	60 1d       	adc	r22, r0
    13f8:	70 1d       	adc	r23, r0
    13fa:	80 1d       	adc	r24, r0
    13fc:	90 1d       	adc	r25, r0
    13fe:	08 95       	ret

00001400 <__udivmodsi4>:
    1400:	a1 e2       	ldi	r26, 0x21	; 33
    1402:	1a 2e       	mov	r1, r26
    1404:	aa 1b       	sub	r26, r26
    1406:	bb 1b       	sub	r27, r27
    1408:	fd 01       	movw	r30, r26
    140a:	0d c0       	rjmp	.+26     	; 0x1426 <__udivmodsi4_ep>

0000140c <__udivmodsi4_loop>:
    140c:	aa 1f       	adc	r26, r26
    140e:	bb 1f       	adc	r27, r27
    1410:	ee 1f       	adc	r30, r30
    1412:	ff 1f       	adc	r31, r31
    1414:	a2 17       	cp	r26, r18
    1416:	b3 07       	cpc	r27, r19
    1418:	e4 07       	cpc	r30, r20
    141a:	f5 07       	cpc	r31, r21
    141c:	20 f0       	brcs	.+8      	; 0x1426 <__udivmodsi4_ep>
    141e:	a2 1b       	sub	r26, r18
    1420:	b3 0b       	sbc	r27, r19
    1422:	e4 0b       	sbc	r30, r20
    1424:	f5 0b       	sbc	r31, r21

00001426 <__udivmodsi4_ep>:
    1426:	66 1f       	adc	r22, r22
    1428:	77 1f       	adc	r23, r23
    142a:	88 1f       	adc	r24, r24
    142c:	99 1f       	adc	r25, r25
    142e:	1a 94       	dec	r1
    1430:	69 f7       	brne	.-38     	; 0x140c <__udivmodsi4_loop>
    1432:	60 95       	com	r22
    1434:	70 95       	com	r23
    1436:	80 95       	com	r24
    1438:	90 95       	com	r25
    143a:	9b 01       	movw	r18, r22
    143c:	ac 01       	movw	r20, r24
    143e:	bd 01       	movw	r22, r26
    1440:	cf 01       	movw	r24, r30
    1442:	08 95       	ret

00001444 <__umulhisi3>:
    1444:	a2 9f       	mul	r26, r18
    1446:	b0 01       	movw	r22, r0
    1448:	b3 9f       	mul	r27, r19
    144a:	c0 01       	movw	r24, r0
    144c:	a3 9f       	mul	r26, r19
    144e:	01 d0       	rcall	.+2      	; 0x1452 <__umulhisi3+0xe>
    1450:	b2 9f       	mul	r27, r18
    1452:	70 0d       	add	r23, r0
    1454:	81 1d       	adc	r24, r1
    1456:	11 24       	eor	r1, r1
    1458:	91 1d       	adc	r25, r1
    145a:	08 95       	ret

0000145c <_exit>:
    145c:	f8 94       	cli

0000145e <__stop_program>:
    145e:	ff cf       	rjmp	.-2      	; 0x145e <__stop_program>
