
KuartisHomework.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803c00  00803c00  000010d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001062  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000041  00803c00  00803c00  000010d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001108  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000d0  00000000  00000000  00001144  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000311e  00000000  00000000  00001214  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002299  00000000  00000000  00004332  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c64  00000000  00000000  000065cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000214  00000000  00000000  00007230  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001859  00000000  00000000  00007444  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000196  00000000  00000000  00008c9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c0  00000000  00000000  00008e33  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 bc 05 	jmp	0xb78	; 0xb78 <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 96 05 	jmp	0xb2c	; 0xb2c <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	37 c0       	rjmp	.+110    	; 0x100 <__EEPROM_REGION_LENGTH__>
      92:	76 c0       	rjmp	.+236    	; 0x180 <__EEPROM_REGION_LENGTH__+0x80>
      94:	b5 c0       	rjmp	.+362    	; 0x200 <__EEPROM_REGION_LENGTH__+0x100>
      96:	c4 c0       	rjmp	.+392    	; 0x220 <__EEPROM_REGION_LENGTH__+0x120>
      98:	db c0       	rjmp	.+438    	; 0x250 <__EEPROM_REGION_LENGTH__+0x150>
      9a:	f2 c0       	rjmp	.+484    	; 0x280 <__EEPROM_REGION_LENGTH__+0x180>
      9c:	08 c1       	rjmp	.+528    	; 0x2ae <__EEPROM_REGION_LENGTH__+0x1ae>
      9e:	17 c1       	rjmp	.+558    	; 0x2ce <__EEPROM_REGION_LENGTH__+0x1ce>
      a0:	de c1       	rjmp	.+956    	; 0x45e <setState+0x18>
      a2:	eb c1       	rjmp	.+982    	; 0x47a <setState+0x34>
      a4:	f9 c1       	rjmp	.+1010   	; 0x498 <setState+0x52>
      a6:	07 c2       	rjmp	.+1038   	; 0x4b6 <setState+0x70>
      a8:	1d c2       	rjmp	.+1082   	; 0x4e4 <setState+0x9e>
      aa:	29 c2       	rjmp	.+1106   	; 0x4fe <setState+0xb8>
      ac:	2d c2       	rjmp	.+1114   	; 0x508 <setState+0xc2>

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf ef       	ldi	r28, 0xFF	; 255
      b4:	cd bf       	out	0x3d, r28	; 61
      b6:	df e3       	ldi	r29, 0x3F	; 63
      b8:	de bf       	out	0x3e, r29	; 62

000000ba <__do_clear_bss>:
      ba:	2c e3       	ldi	r18, 0x3C	; 60
      bc:	a0 e0       	ldi	r26, 0x00	; 0
      be:	bc e3       	ldi	r27, 0x3C	; 60
      c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
      c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
      c4:	a1 34       	cpi	r26, 0x41	; 65
      c6:	b2 07       	cpc	r27, r18
      c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
      ca:	73 d7       	rcall	.+3814   	; 0xfb2 <main>
      cc:	c8 c7       	rjmp	.+3984   	; 0x105e <_exit>

000000ce <__bad_interrupt>:
      ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <Buzzer>:
BUZZER_SOUND_INFO BuzzerState;
volatile int32_t BuzzerFlag = 0;
volatile int32_t BuzzerCounter = 0;
volatile int32_t Pitch_flag=0;
void Buzzer(){
	BuzzerFlag=1;
      d0:	81 e0       	ldi	r24, 0x01	; 1
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	a0 e0       	ldi	r26, 0x00	; 0
      d6:	b0 e0       	ldi	r27, 0x00	; 0
      d8:	80 93 34 3c 	sts	0x3C34, r24	; 0x803c34 <BuzzerFlag>
      dc:	90 93 35 3c 	sts	0x3C35, r25	; 0x803c35 <BuzzerFlag+0x1>
      e0:	a0 93 36 3c 	sts	0x3C36, r26	; 0x803c36 <BuzzerFlag+0x2>
      e4:	b0 93 37 3c 	sts	0x3C37, r27	; 0x803c37 <BuzzerFlag+0x3>
	switch(BuzzerState.currentState){
      e8:	e0 91 40 3c 	lds	r30, 0x3C40	; 0x803c40 <BuzzerState>
      ec:	8e 2f       	mov	r24, r30
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	88 30       	cpi	r24, 0x08	; 8
      f2:	91 05       	cpc	r25, r1
      f4:	08 f0       	brcs	.+2      	; 0xf8 <Buzzer+0x28>
      f6:	01 c1       	rjmp	.+514    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
      f8:	fc 01       	movw	r30, r24
      fa:	e8 5b       	subi	r30, 0xB8	; 184
      fc:	ff 4f       	sbci	r31, 0xFF	; 255
      fe:	09 94       	ijmp
		case(POWER_ON_SOUND):
			if(BuzzerCounter%2==0&&Pitch_flag==1){
     100:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <BuzzerCounter>
     104:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     108:	a0 91 32 3c 	lds	r26, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     10c:	b0 91 33 3c 	lds	r27, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     110:	80 fd       	sbrc	r24, 0
     112:	11 c0       	rjmp	.+34     	; 0x136 <__EEPROM_REGION_LENGTH__+0x36>
     114:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <Pitch_flag>
     118:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <Pitch_flag+0x1>
     11c:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <Pitch_flag+0x2>
     120:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <Pitch_flag+0x3>
     124:	01 97       	sbiw	r24, 0x01	; 1
     126:	a1 05       	cpc	r26, r1
     128:	b1 05       	cpc	r27, r1
     12a:	29 f4       	brne	.+10     	; 0x136 <__EEPROM_REGION_LENGTH__+0x36>
				PORTD.OUT ^= (1<<BUZZER);
     12c:	e0 e6       	ldi	r30, 0x60	; 96
     12e:	f4 e0       	ldi	r31, 0x04	; 4
     130:	84 81       	ldd	r24, Z+4	; 0x04
     132:	80 58       	subi	r24, 0x80	; 128
     134:	84 83       	std	Z+4, r24	; 0x04
			}
			if(BuzzerCounter%10==0&&Pitch_flag==0){
     136:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     13a:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     13e:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     142:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     146:	2a e0       	ldi	r18, 0x0A	; 10
     148:	30 e0       	ldi	r19, 0x00	; 0
     14a:	40 e0       	ldi	r20, 0x00	; 0
     14c:	50 e0       	ldi	r21, 0x00	; 0
     14e:	33 d7       	rcall	.+3686   	; 0xfb6 <__divmodsi4>
     150:	67 2b       	or	r22, r23
     152:	68 2b       	or	r22, r24
     154:	69 2b       	or	r22, r25
     156:	09 f0       	breq	.+2      	; 0x15a <__EEPROM_REGION_LENGTH__+0x5a>
     158:	d0 c0       	rjmp	.+416    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
     15a:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <Pitch_flag>
     15e:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <Pitch_flag+0x1>
     162:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <Pitch_flag+0x2>
     166:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <Pitch_flag+0x3>
     16a:	89 2b       	or	r24, r25
     16c:	8a 2b       	or	r24, r26
     16e:	8b 2b       	or	r24, r27
     170:	09 f0       	breq	.+2      	; 0x174 <__EEPROM_REGION_LENGTH__+0x74>
     172:	c3 c0       	rjmp	.+390    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     174:	e0 e6       	ldi	r30, 0x60	; 96
     176:	f4 e0       	ldi	r31, 0x04	; 4
     178:	84 81       	ldd	r24, Z+4	; 0x04
     17a:	80 58       	subi	r24, 0x80	; 128
     17c:	84 83       	std	Z+4, r24	; 0x04
     17e:	08 95       	ret
			}
			
						
			break;
		case(POWER_OFF_SOUND):
			if(BuzzerCounter%2==0&&Pitch_flag==0){
     180:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <BuzzerCounter>
     184:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     188:	a0 91 32 3c 	lds	r26, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     18c:	b0 91 33 3c 	lds	r27, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     190:	80 fd       	sbrc	r24, 0
     192:	11 c0       	rjmp	.+34     	; 0x1b6 <__EEPROM_REGION_LENGTH__+0xb6>
     194:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <Pitch_flag>
     198:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <Pitch_flag+0x1>
     19c:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <Pitch_flag+0x2>
     1a0:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <Pitch_flag+0x3>
     1a4:	89 2b       	or	r24, r25
     1a6:	8a 2b       	or	r24, r26
     1a8:	8b 2b       	or	r24, r27
     1aa:	29 f4       	brne	.+10     	; 0x1b6 <__EEPROM_REGION_LENGTH__+0xb6>
				PORTD.OUT ^= (1<<BUZZER);
     1ac:	e0 e6       	ldi	r30, 0x60	; 96
     1ae:	f4 e0       	ldi	r31, 0x04	; 4
     1b0:	84 81       	ldd	r24, Z+4	; 0x04
     1b2:	80 58       	subi	r24, 0x80	; 128
     1b4:	84 83       	std	Z+4, r24	; 0x04
			}
			if(BuzzerCounter%10==0&&Pitch_flag==1){
     1b6:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     1ba:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     1be:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     1c2:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     1c6:	2a e0       	ldi	r18, 0x0A	; 10
     1c8:	30 e0       	ldi	r19, 0x00	; 0
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	50 e0       	ldi	r21, 0x00	; 0
     1ce:	f3 d6       	rcall	.+3558   	; 0xfb6 <__divmodsi4>
     1d0:	67 2b       	or	r22, r23
     1d2:	68 2b       	or	r22, r24
     1d4:	69 2b       	or	r22, r25
     1d6:	09 f0       	breq	.+2      	; 0x1da <__EEPROM_REGION_LENGTH__+0xda>
     1d8:	90 c0       	rjmp	.+288    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
     1da:	80 91 2c 3c 	lds	r24, 0x3C2C	; 0x803c2c <Pitch_flag>
     1de:	90 91 2d 3c 	lds	r25, 0x3C2D	; 0x803c2d <Pitch_flag+0x1>
     1e2:	a0 91 2e 3c 	lds	r26, 0x3C2E	; 0x803c2e <Pitch_flag+0x2>
     1e6:	b0 91 2f 3c 	lds	r27, 0x3C2F	; 0x803c2f <Pitch_flag+0x3>
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	a1 05       	cpc	r26, r1
     1ee:	b1 05       	cpc	r27, r1
     1f0:	09 f0       	breq	.+2      	; 0x1f4 <__EEPROM_REGION_LENGTH__+0xf4>
     1f2:	83 c0       	rjmp	.+262    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     1f4:	e0 e6       	ldi	r30, 0x60	; 96
     1f6:	f4 e0       	ldi	r31, 0x04	; 4
     1f8:	84 81       	ldd	r24, Z+4	; 0x04
     1fa:	80 58       	subi	r24, 0x80	; 128
     1fc:	84 83       	std	Z+4, r24	; 0x04
     1fe:	08 95       	ret
			}
		break;
		case(INC_SOUND):
			if(BuzzerCounter%2==0){
     200:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <BuzzerCounter>
     204:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     208:	a0 91 32 3c 	lds	r26, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     20c:	b0 91 33 3c 	lds	r27, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     210:	80 fd       	sbrc	r24, 0
     212:	73 c0       	rjmp	.+230    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     214:	e0 e6       	ldi	r30, 0x60	; 96
     216:	f4 e0       	ldi	r31, 0x04	; 4
     218:	84 81       	ldd	r24, Z+4	; 0x04
     21a:	80 58       	subi	r24, 0x80	; 128
     21c:	84 83       	std	Z+4, r24	; 0x04
     21e:	08 95       	ret
			}
			break;
		case(DEC_SOUND):
			if(BuzzerCounter%10==0){
     220:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     224:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     228:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     22c:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     230:	2a e0       	ldi	r18, 0x0A	; 10
     232:	30 e0       	ldi	r19, 0x00	; 0
     234:	40 e0       	ldi	r20, 0x00	; 0
     236:	50 e0       	ldi	r21, 0x00	; 0
     238:	be d6       	rcall	.+3452   	; 0xfb6 <__divmodsi4>
     23a:	67 2b       	or	r22, r23
     23c:	68 2b       	or	r22, r24
     23e:	69 2b       	or	r22, r25
     240:	09 f0       	breq	.+2      	; 0x244 <__EEPROM_REGION_LENGTH__+0x144>
     242:	5b c0       	rjmp	.+182    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     244:	e0 e6       	ldi	r30, 0x60	; 96
     246:	f4 e0       	ldi	r31, 0x04	; 4
     248:	84 81       	ldd	r24, Z+4	; 0x04
     24a:	80 58       	subi	r24, 0x80	; 128
     24c:	84 83       	std	Z+4, r24	; 0x04
     24e:	08 95       	ret
			}
			break;
		case(LIGHT_SOUND):
				if(BuzzerCounter%20==0){
     250:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     254:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     258:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     25c:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     260:	24 e1       	ldi	r18, 0x14	; 20
     262:	30 e0       	ldi	r19, 0x00	; 0
     264:	40 e0       	ldi	r20, 0x00	; 0
     266:	50 e0       	ldi	r21, 0x00	; 0
     268:	a6 d6       	rcall	.+3404   	; 0xfb6 <__divmodsi4>
     26a:	67 2b       	or	r22, r23
     26c:	68 2b       	or	r22, r24
     26e:	69 2b       	or	r22, r25
     270:	09 f0       	breq	.+2      	; 0x274 <__EEPROM_REGION_LENGTH__+0x174>
     272:	43 c0       	rjmp	.+134    	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
					PORTD.OUT ^= (1<<BUZZER);
     274:	e0 e6       	ldi	r30, 0x60	; 96
     276:	f4 e0       	ldi	r31, 0x04	; 4
     278:	84 81       	ldd	r24, Z+4	; 0x04
     27a:	80 58       	subi	r24, 0x80	; 128
     27c:	84 83       	std	Z+4, r24	; 0x04
     27e:	08 95       	ret
				}
			break;
		case(DEV_INIT_SOUND):
			if(BuzzerCounter%10==0){
     280:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     284:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     288:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     28c:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     290:	2a e0       	ldi	r18, 0x0A	; 10
     292:	30 e0       	ldi	r19, 0x00	; 0
     294:	40 e0       	ldi	r20, 0x00	; 0
     296:	50 e0       	ldi	r21, 0x00	; 0
     298:	8e d6       	rcall	.+3356   	; 0xfb6 <__divmodsi4>
     29a:	67 2b       	or	r22, r23
     29c:	68 2b       	or	r22, r24
     29e:	69 2b       	or	r22, r25
     2a0:	61 f5       	brne	.+88     	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     2a2:	e0 e6       	ldi	r30, 0x60	; 96
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	80 58       	subi	r24, 0x80	; 128
     2aa:	84 83       	std	Z+4, r24	; 0x04
     2ac:	08 95       	ret
			}
			break;
		case(DEV_MODE_SOUND):
			if(BuzzerCounter%2==0){
     2ae:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <BuzzerCounter>
     2b2:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     2b6:	a0 91 32 3c 	lds	r26, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     2ba:	b0 91 33 3c 	lds	r27, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     2be:	80 fd       	sbrc	r24, 0
     2c0:	1c c0       	rjmp	.+56     	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     2c2:	e0 e6       	ldi	r30, 0x60	; 96
     2c4:	f4 e0       	ldi	r31, 0x04	; 4
     2c6:	84 81       	ldd	r24, Z+4	; 0x04
     2c8:	80 58       	subi	r24, 0x80	; 128
     2ca:	84 83       	std	Z+4, r24	; 0x04
     2cc:	08 95       	ret
			}
			break;
		case(LIGHT_ADJ_SOUND):
			if(BuzzerCounter%10==0){
     2ce:	60 91 30 3c 	lds	r22, 0x3C30	; 0x803c30 <BuzzerCounter>
     2d2:	70 91 31 3c 	lds	r23, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     2d6:	80 91 32 3c 	lds	r24, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     2da:	90 91 33 3c 	lds	r25, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     2de:	2a e0       	ldi	r18, 0x0A	; 10
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	40 e0       	ldi	r20, 0x00	; 0
     2e4:	50 e0       	ldi	r21, 0x00	; 0
     2e6:	67 d6       	rcall	.+3278   	; 0xfb6 <__divmodsi4>
     2e8:	67 2b       	or	r22, r23
     2ea:	68 2b       	or	r22, r24
     2ec:	69 2b       	or	r22, r25
     2ee:	29 f4       	brne	.+10     	; 0x2fa <__EEPROM_REGION_LENGTH__+0x1fa>
				PORTD.OUT ^= (1<<BUZZER);
     2f0:	e0 e6       	ldi	r30, 0x60	; 96
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	84 81       	ldd	r24, Z+4	; 0x04
     2f6:	80 58       	subi	r24, 0x80	; 128
     2f8:	84 83       	std	Z+4, r24	; 0x04
     2fa:	08 95       	ret

000002fc <VerifyAddress>:
/* First 2 bytes are address decimals. They are "129" and "102" in decimal
We need to verify this decimals, because different remotes can send IR signals also.
This function verifies first two bytes. Returns "1" if the address are true, "0" if false.                                                                   */
/************************************************************************/
bool VerifyAddress(){
	if((command_register & 0xFFFF0000) == ADDRESS_bm)
     2fc:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     300:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     304:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     308:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     30c:	88 27       	eor	r24, r24
     30e:	99 27       	eor	r25, r25
     310:	00 97       	sbiw	r24, 0x00	; 0
     312:	a6 46       	sbci	r26, 0x66	; 102
     314:	b1 48       	sbci	r27, 0x81	; 129
     316:	11 f4       	brne	.+4      	; 0x31c <VerifyAddress+0x20>
	return true;
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	08 95       	ret
	else return false;
     31c:	80 e0       	ldi	r24, 0x00	; 0
}
     31e:	08 95       	ret

00000320 <GenerateRepeatCode>:
void GenerateRepeatCode(){
	tick_counter=0;
     320:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <tick_counter>
     324:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <tick_counter+0x1>
     328:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <tick_counter+0x2>
     32c:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <tick_counter+0x3>
	hold_flag=1;
     330:	81 e0       	ldi	r24, 0x01	; 1
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	80 93 14 3c 	sts	0x3C14, r24	; 0x803c14 <hold_flag>
     338:	90 93 15 3c 	sts	0x3C15, r25	; 0x803c15 <hold_flag+0x1>
	if(InputState.currentState==POWER || InputState.currentState==POWER_HOLD){
     33c:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     340:	82 30       	cpi	r24, 0x02	; 2
     342:	20 f4       	brcc	.+8      	; 0x34c <GenerateRepeatCode+0x2c>
		InputState.currentState=POWER_HOLD;
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     34a:	08 95       	ret
		
	}
	else if(InputState.currentState==INCREMENT || InputState.currentState==INCREMENT_HOLD){
     34c:	9e ef       	ldi	r25, 0xFE	; 254
     34e:	98 0f       	add	r25, r24
     350:	92 30       	cpi	r25, 0x02	; 2
     352:	20 f4       	brcc	.+8      	; 0x35c <GenerateRepeatCode+0x3c>
		InputState.currentState=INCREMENT_HOLD;
     354:	83 e0       	ldi	r24, 0x03	; 3
     356:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     35a:	08 95       	ret
	}
	else if(InputState.currentState==DECREMENT ||InputState.currentState==DECREMENT_HOLD){
     35c:	9c ef       	ldi	r25, 0xFC	; 252
     35e:	98 0f       	add	r25, r24
     360:	92 30       	cpi	r25, 0x02	; 2
     362:	20 f4       	brcc	.+8      	; 0x36c <GenerateRepeatCode+0x4c>
		InputState.currentState=DECREMENT_HOLD;
     364:	85 e0       	ldi	r24, 0x05	; 5
     366:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     36a:	08 95       	ret
	}
	else if(InputState.currentState==LIGHT || InputState.currentState==LIGHT_HOLD){
     36c:	86 50       	subi	r24, 0x06	; 6
     36e:	82 30       	cpi	r24, 0x02	; 2
     370:	18 f4       	brcc	.+6      	; 0x378 <GenerateRepeatCode+0x58>
			InputState.currentState=LIGHT_HOLD;
     372:	87 e0       	ldi	r24, 0x07	; 7
     374:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     378:	08 95       	ret

0000037a <disableIR_ISR>:

/************************************************************************/
/* This function disables interrupt for IR receiver                                                                     */
/************************************************************************/
void disableIR_ISR(){
	PORTA.PIN3CTRL &= 0b00000000;
     37a:	e0 e0       	ldi	r30, 0x00	; 0
     37c:	f4 e0       	ldi	r31, 0x04	; 4
     37e:	83 89       	ldd	r24, Z+19	; 0x13
     380:	13 8a       	std	Z+19, r1	; 0x13
     382:	08 95       	ret

00000384 <enableIR_ISR>:
}
/************************************************************************/
/* This function enables interrupt for IR Receiver                                                                     */
/************************************************************************/
void enableIR_ISR(){
	PORTA.PIN3CTRL |= 0b00000011;
     384:	e0 e0       	ldi	r30, 0x00	; 0
     386:	f4 e0       	ldi	r31, 0x04	; 4
     388:	83 89       	ldd	r24, Z+19	; 0x13
     38a:	83 60       	ori	r24, 0x03	; 3
     38c:	83 8b       	std	Z+19, r24	; 0x13
	RTC.CNT = 0;//reset counter
     38e:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     392:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
     396:	08 95       	ret

00000398 <disableRTC>:
}
void disableRTC(){
	RTC.CNT = 0;//reset counter
     398:	e0 e4       	ldi	r30, 0x40	; 64
     39a:	f1 e0       	ldi	r31, 0x01	; 1
     39c:	10 86       	std	Z+8, r1	; 0x08
     39e:	11 86       	std	Z+9, r1	; 0x09
	RTC.INTCTRL &= ~RTC_OVF_bm;
     3a0:	82 81       	ldd	r24, Z+2	; 0x02
     3a2:	8e 7f       	andi	r24, 0xFE	; 254
     3a4:	82 83       	std	Z+2, r24	; 0x02
	tick_counter = 0;
     3a6:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <tick_counter>
     3aa:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <tick_counter+0x1>
     3ae:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <tick_counter+0x2>
     3b2:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <tick_counter+0x3>
     3b6:	08 95       	ret

000003b8 <enableRTC>:
}
void enableRTC(){
	RTC.INTCTRL |= RTC_OVF_bm;
     3b8:	e0 e4       	ldi	r30, 0x40	; 64
     3ba:	f1 e0       	ldi	r31, 0x01	; 1
     3bc:	82 81       	ldd	r24, Z+2	; 0x02
     3be:	81 60       	ori	r24, 0x01	; 1
     3c0:	82 83       	std	Z+2, r24	; 0x02
     3c2:	08 95       	ret

000003c4 <DevModeBlink>:
	
	 
}
void DevModeBlink(){
	PORTD.OUT = 0x00; //Close all motors
     3c4:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
	switch(DevModeLightState.currentState){
     3c8:	80 91 3f 3c 	lds	r24, 0x3C3F	; 0x803c3f <DevModeLightState>
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	89 f0       	breq	.+34     	; 0x3f2 <DevModeBlink+0x2e>
     3d0:	28 f0       	brcs	.+10     	; 0x3dc <DevModeBlink+0x18>
     3d2:	82 30       	cpi	r24, 0x02	; 2
     3d4:	c9 f0       	breq	.+50     	; 0x408 <__DATA_REGION_LENGTH__+0x8>
     3d6:	83 30       	cpi	r24, 0x03	; 3
     3d8:	11 f1       	breq	.+68     	; 0x41e <__DATA_REGION_LENGTH__+0x1e>
     3da:	2b c0       	rjmp	.+86     	; 0x432 <__DATA_REGION_LENGTH__+0x32>
		case(DEV_ONE):
			PORTA.OUT = 0xFF;
     3dc:	e0 e0       	ldi	r30, 0x00	; 0
     3de:	f4 e0       	ldi	r31, 0x04	; 4
     3e0:	8f ef       	ldi	r24, 0xFF	; 255
     3e2:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2);
     3e4:	84 81       	ldd	r24, Z+4	; 0x04
     3e6:	8a 7f       	andi	r24, 0xFA	; 250
     3e8:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_TWO;
     3ea:	81 e0       	ldi	r24, 0x01	; 1
     3ec:	80 93 3f 3c 	sts	0x3C3F, r24	; 0x803c3f <DevModeLightState>
		break;
     3f0:	08 95       	ret
		case(DEV_TWO):
			PORTA.OUT = 0xFF;
     3f2:	e0 e0       	ldi	r30, 0x00	; 0
     3f4:	f4 e0       	ldi	r31, 0x04	; 4
     3f6:	8f ef       	ldi	r24, 0xFF	; 255
     3f8:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_2) & ~(1<<LED_3);
     3fa:	84 81       	ldd	r24, Z+4	; 0x04
     3fc:	89 7f       	andi	r24, 0xF9	; 249
     3fe:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_THREE;
     400:	82 e0       	ldi	r24, 0x02	; 2
     402:	80 93 3f 3c 	sts	0x3C3F, r24	; 0x803c3f <DevModeLightState>
			break;
     406:	08 95       	ret
		case(DEV_THREE):
			PORTA.OUT = 0xFF;
     408:	e0 e0       	ldi	r30, 0x00	; 0
     40a:	f4 e0       	ldi	r31, 0x04	; 4
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_3) & ~(1<<LED_4);
     410:	84 81       	ldd	r24, Z+4	; 0x04
     412:	8d 7d       	andi	r24, 0xDD	; 221
     414:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_FOUR;
     416:	83 e0       	ldi	r24, 0x03	; 3
     418:	80 93 3f 3c 	sts	0x3C3F, r24	; 0x803c3f <DevModeLightState>
			break;
     41c:	08 95       	ret
		case(DEV_FOUR):
			PORTA.OUT = 0xFF;
     41e:	e0 e0       	ldi	r30, 0x00	; 0
     420:	f4 e0       	ldi	r31, 0x04	; 4
     422:	8f ef       	ldi	r24, 0xFF	; 255
     424:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_4);
     426:	84 81       	ldd	r24, Z+4	; 0x04
     428:	8e 7d       	andi	r24, 0xDE	; 222
     42a:	84 83       	std	Z+4, r24	; 0x04
			DevModeLightState.currentState = DEV_ONE;	
     42c:	10 92 3f 3c 	sts	0x3C3F, r1	; 0x803c3f <DevModeLightState>
			break;
     430:	08 95       	ret
		default:
			DevModeLightState.currentState = DEV_ONE;
     432:	10 92 3f 3c 	sts	0x3C3F, r1	; 0x803c3f <DevModeLightState>
			PORTA.OUT = 0xFF;
     436:	e0 e0       	ldi	r30, 0x00	; 0
     438:	f4 e0       	ldi	r31, 0x04	; 4
     43a:	8f ef       	ldi	r24, 0xFF	; 255
     43c:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_4);
     43e:	84 81       	ldd	r24, Z+4	; 0x04
     440:	8e 7d       	andi	r24, 0xDE	; 222
     442:	84 83       	std	Z+4, r24	; 0x04
     444:	08 95       	ret

00000446 <setState>:
	}
}

void setState(){
	
	switch(State.currentState){
     446:	e0 91 3d 3c 	lds	r30, 0x3C3D	; 0x803c3d <State>
     44a:	8e 2f       	mov	r24, r30
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	87 30       	cpi	r24, 0x07	; 7
     450:	91 05       	cpc	r25, r1
     452:	08 f0       	brcs	.+2      	; 0x456 <setState+0x10>
     454:	56 c0       	rjmp	.+172    	; 0x502 <setState+0xbc>
     456:	fc 01       	movw	r30, r24
     458:	e0 5b       	subi	r30, 0xB0	; 176
     45a:	ff 4f       	sbci	r31, 0xFF	; 255
     45c:	09 94       	ijmp
		case(OFF):
			PORTA.OUT = 0xFF; // All LEDs OFF
     45e:	8f ef       	ldi	r24, 0xFF	; 255
     460:	80 93 04 04 	sts	0x0404, r24	; 0x800404 <__RODATA_PM_OFFSET__+0x7fc404>
			PORTD.OUT = 0x00; // All MOTORs OFF
     464:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <__RODATA_PM_OFFSET__+0x7fc464>
			boost_total_timer = 0;//Coming from BOOST state, reset boost timer.
     468:	10 92 0c 3c 	sts	0x3C0C, r1	; 0x803c0c <boost_total_timer>
     46c:	10 92 0d 3c 	sts	0x3C0D, r1	; 0x803c0d <boost_total_timer+0x1>
     470:	10 92 0e 3c 	sts	0x3C0E, r1	; 0x803c0e <boost_total_timer+0x2>
     474:	10 92 0f 3c 	sts	0x3C0F, r1	; 0x803c0f <boost_total_timer+0x3>
			break;
     478:	08 95       	ret
		case(ONE):
			//Only LED_1 is on.
			PORTA.OUT = 0xFF;
     47a:	e0 e0       	ldi	r30, 0x00	; 0
     47c:	f4 e0       	ldi	r31, 0x04	; 4
     47e:	8f ef       	ldi	r24, 0xFF	; 255
     480:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1);
     482:	84 81       	ldd	r24, Z+4	; 0x04
     484:	8e 7f       	andi	r24, 0xFE	; 254
     486:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_2);//CLOSE MOTOR_2
     488:	e0 e6       	ldi	r30, 0x60	; 96
     48a:	f4 e0       	ldi	r31, 0x04	; 4
     48c:	84 81       	ldd	r24, Z+4	; 0x04
     48e:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_1);//OPEN MOTOR_1
     490:	84 81       	ldd	r24, Z+4	; 0x04
     492:	80 64       	ori	r24, 0x40	; 64
     494:	84 83       	std	Z+4, r24	; 0x04
			break;
     496:	08 95       	ret
		case(TWO):
			//LEDs 1-2 are on.
			PORTA.OUT = 0xFF;
     498:	e0 e0       	ldi	r30, 0x00	; 0
     49a:	f4 e0       	ldi	r31, 0x04	; 4
     49c:	8f ef       	ldi	r24, 0xFF	; 255
     49e:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2);
     4a0:	84 81       	ldd	r24, Z+4	; 0x04
     4a2:	8a 7f       	andi	r24, 0xFA	; 250
     4a4:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_3);//CLOSE MOTOR_3
     4a6:	e0 e6       	ldi	r30, 0x60	; 96
     4a8:	f4 e0       	ldi	r31, 0x04	; 4
     4aa:	84 81       	ldd	r24, Z+4	; 0x04
     4ac:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_2);//OPEN MOTOR_2
     4ae:	84 81       	ldd	r24, Z+4	; 0x04
     4b0:	80 62       	ori	r24, 0x20	; 32
     4b2:	84 83       	std	Z+4, r24	; 0x04
			
			break;
     4b4:	08 95       	ret
		case(THREE):
			//LEDs 1-2-3 are on.
			boost_total_timer = 0; // Coming from BOOST state, reset boost timer.
     4b6:	10 92 0c 3c 	sts	0x3C0C, r1	; 0x803c0c <boost_total_timer>
     4ba:	10 92 0d 3c 	sts	0x3C0D, r1	; 0x803c0d <boost_total_timer+0x1>
     4be:	10 92 0e 3c 	sts	0x3C0E, r1	; 0x803c0e <boost_total_timer+0x2>
     4c2:	10 92 0f 3c 	sts	0x3C0F, r1	; 0x803c0f <boost_total_timer+0x3>
			PORTA.OUT = 0xFF;
     4c6:	e0 e0       	ldi	r30, 0x00	; 0
     4c8:	f4 e0       	ldi	r31, 0x04	; 4
     4ca:	8f ef       	ldi	r24, 0xFF	; 255
     4cc:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~(1<<LED_2) & ~(1<<LED_3);
     4ce:	84 81       	ldd	r24, Z+4	; 0x04
     4d0:	88 7f       	andi	r24, 0xF8	; 248
     4d2:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT &= ~(0<<MOTOR_RELAY_4);//CLOSE MOTOR_4
     4d4:	e0 e6       	ldi	r30, 0x60	; 96
     4d6:	f4 e0       	ldi	r31, 0x04	; 4
     4d8:	84 81       	ldd	r24, Z+4	; 0x04
     4da:	84 83       	std	Z+4, r24	; 0x04
			PORTD.OUT |= (1<<MOTOR_RELAY_3);//OPEN MOTOR_3
     4dc:	84 81       	ldd	r24, Z+4	; 0x04
     4de:	80 61       	ori	r24, 0x10	; 16
     4e0:	84 83       	std	Z+4, r24	; 0x04
			
			//
			break;
     4e2:	08 95       	ret
		case(BOOST):
			//LEDs 1-2-3-4 are on. After 15 min, go to state THREE.
			PORTA.OUT = 0xFF;
     4e4:	e0 e0       	ldi	r30, 0x00	; 0
     4e6:	f4 e0       	ldi	r31, 0x04	; 4
     4e8:	8f ef       	ldi	r24, 0xFF	; 255
     4ea:	84 83       	std	Z+4, r24	; 0x04
			PORTA.OUT &= ~(1<<LED_1) & ~ (1<<LED_2) & ~ (1<<LED_3) & ~(1<<LED_4);
     4ec:	84 81       	ldd	r24, Z+4	; 0x04
     4ee:	88 7d       	andi	r24, 0xD8	; 216
     4f0:	84 83       	std	Z+4, r24	; 0x04
			
			PORTD.OUT |= (1<<MOTOR_RELAY_4);//OPEN MOTOR_4
     4f2:	e0 e6       	ldi	r30, 0x60	; 96
     4f4:	f4 e0       	ldi	r31, 0x04	; 4
     4f6:	84 81       	ldd	r24, Z+4	; 0x04
     4f8:	84 60       	ori	r24, 0x04	; 4
     4fa:	84 83       	std	Z+4, r24	; 0x04
			break;
     4fc:	08 95       	ret
		case(DEV_MODE):
				DevModeBlink();
     4fe:	62 df       	rcall	.-316    	; 0x3c4 <DevModeBlink>
			break;
     500:	08 95       	ret
		case(BRIGHT_ADJ):
				
			break;	
		default:
			State.currentState = ONE; // In case of errors or out of state machine, go to state one.
     502:	81 e0       	ldi	r24, 0x01	; 1
     504:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     508:	08 95       	ret

0000050a <WriteInput>:
/************************************************************************/
/* This function changes the State of the system according to the input from the controller                                                                     */
/************************************************************************/
void WriteInput(){
	
	switch(InputState.currentState){
     50a:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     50e:	82 30       	cpi	r24, 0x02	; 2
     510:	e1 f0       	breq	.+56     	; 0x54a <WriteInput+0x40>
     512:	18 f4       	brcc	.+6      	; 0x51a <WriteInput+0x10>
     514:	88 23       	and	r24, r24
     516:	39 f0       	breq	.+14     	; 0x526 <WriteInput+0x1c>
     518:	08 95       	ret
     51a:	84 30       	cpi	r24, 0x04	; 4
     51c:	71 f1       	breq	.+92     	; 0x57a <WriteInput+0x70>
     51e:	86 30       	cpi	r24, 0x06	; 6
     520:	09 f4       	brne	.+2      	; 0x524 <WriteInput+0x1a>
     522:	43 c0       	rjmp	.+134    	; 0x5aa <WriteInput+0xa0>
     524:	08 95       	ret
		case(POWER):
			if(State.currentState == OFF){
     526:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     52a:	81 11       	cpse	r24, r1
     52c:	07 c0       	rjmp	.+14     	; 0x53c <WriteInput+0x32>
				State.currentState = ONE;
     52e:	81 e0       	ldi	r24, 0x01	; 1
     530:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
				BuzzerState.currentState= POWER_ON_SOUND;
     534:	10 92 40 3c 	sts	0x3C40, r1	; 0x803c40 <BuzzerState>
				Buzzer();
     538:	cb dd       	rcall	.-1130   	; 0xd0 <Buzzer>
     53a:	08 95       	ret
			}
			else{
				State.currentState = OFF;
     53c:	10 92 3d 3c 	sts	0x3C3D, r1	; 0x803c3d <State>
				BuzzerState.currentState= POWER_OFF_SOUND;
     540:	81 e0       	ldi	r24, 0x01	; 1
     542:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
				Buzzer();
     546:	c4 dd       	rcall	.-1144   	; 0xd0 <Buzzer>
     548:	08 95       	ret
			}
			break;
		case(INCREMENT):
			BuzzerState.currentState= INC_SOUND;
     54a:	82 e0       	ldi	r24, 0x02	; 2
     54c:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     550:	bf dd       	rcall	.-1154   	; 0xd0 <Buzzer>
			if(State.currentState==ONE){
     552:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     556:	81 30       	cpi	r24, 0x01	; 1
     558:	21 f4       	brne	.+8      	; 0x562 <WriteInput+0x58>
				State.currentState = TWO;
     55a:	82 e0       	ldi	r24, 0x02	; 2
     55c:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     560:	08 95       	ret
			}
			else if(State.currentState == TWO){
     562:	82 30       	cpi	r24, 0x02	; 2
     564:	21 f4       	brne	.+8      	; 0x56e <WriteInput+0x64>
				State.currentState=THREE;
     566:	83 e0       	ldi	r24, 0x03	; 3
     568:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     56c:	08 95       	ret
			}
			else if(State.currentState == THREE) {
     56e:	83 30       	cpi	r24, 0x03	; 3
     570:	51 f5       	brne	.+84     	; 0x5c6 <WriteInput+0xbc>
				State.currentState = BOOST;
     572:	84 e0       	ldi	r24, 0x04	; 4
     574:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     578:	08 95       	ret
			}
			break;
		case(DECREMENT):
			BuzzerState.currentState= DEC_SOUND;
     57a:	83 e0       	ldi	r24, 0x03	; 3
     57c:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     580:	a7 dd       	rcall	.-1202   	; 0xd0 <Buzzer>
			if(State.currentState==BOOST){
     582:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     586:	84 30       	cpi	r24, 0x04	; 4
     588:	21 f4       	brne	.+8      	; 0x592 <WriteInput+0x88>
				State.currentState = THREE;
     58a:	83 e0       	ldi	r24, 0x03	; 3
     58c:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     590:	08 95       	ret
			}
			else if(State.currentState == THREE){
     592:	83 30       	cpi	r24, 0x03	; 3
     594:	21 f4       	brne	.+8      	; 0x59e <WriteInput+0x94>
				State.currentState=TWO;
     596:	82 e0       	ldi	r24, 0x02	; 2
     598:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     59c:	08 95       	ret
			}
			else if(State.currentState == TWO) {
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	91 f4       	brne	.+36     	; 0x5c6 <WriteInput+0xbc>
				State.currentState = ONE;
     5a2:	81 e0       	ldi	r24, 0x01	; 1
     5a4:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
     5a8:	08 95       	ret
			}
			break;
		case(LIGHT):
			if(LightState.currentState == LIGHT_ON){
     5aa:	80 91 38 3c 	lds	r24, 0x3C38	; 0x803c38 <LightState>
     5ae:	81 11       	cpse	r24, r1
     5b0:	04 c0       	rjmp	.+8      	; 0x5ba <WriteInput+0xb0>
				LightState.currentState=LIGHT_OFF;
     5b2:	81 e0       	ldi	r24, 0x01	; 1
     5b4:	80 93 38 3c 	sts	0x3C38, r24	; 0x803c38 <LightState>
     5b8:	02 c0       	rjmp	.+4      	; 0x5be <WriteInput+0xb4>
			}
			else{
				LightState.currentState=LIGHT_ON;
     5ba:	10 92 38 3c 	sts	0x3C38, r1	; 0x803c38 <LightState>
			}
			BuzzerState.currentState= LIGHT_SOUND;
     5be:	84 e0       	ldi	r24, 0x04	; 4
     5c0:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     5c4:	85 dd       	rcall	.-1270   	; 0xd0 <Buzzer>
     5c6:	08 95       	ret

000005c8 <DecodeCommand>:
/* This functions decodes incoming command. There are 4 different commands which are;
POWER, INCREMENT, DECREMENT and  LIGHT. There can also be REPEAT code which happens when the button 
is held down.Functions changes the current state of InputState instance.                                                                     */
/************************************************************************/
void DecodeCommand(){
	if((command_register&0x0000FFFF)==IR_POWER_bm){
     5c8:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     5cc:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     5d0:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     5d4:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     5d8:	aa 27       	eor	r26, r26
     5da:	bb 27       	eor	r27, r27
     5dc:	8e 37       	cpi	r24, 0x7E	; 126
     5de:	91 48       	sbci	r25, 0x81	; 129
     5e0:	a1 05       	cpc	r26, r1
     5e2:	b1 05       	cpc	r27, r1
     5e4:	29 f4       	brne	.+10     	; 0x5f0 <DecodeCommand+0x28>
		InputState.currentState = POWER;
     5e6:	10 92 39 3c 	sts	0x3C39, r1	; 0x803c39 <InputState>
		WriteInput();
     5ea:	8f df       	rcall	.-226    	; 0x50a <WriteInput>
		setState();
     5ec:	2c df       	rcall	.-424    	; 0x446 <setState>
		return;
     5ee:	08 95       	ret
	}
	else if((command_register&0x0000FFFF)==IR_MINUS_bm){
     5f0:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     5f4:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     5f8:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     5fc:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     600:	aa 27       	eor	r26, r26
     602:	bb 27       	eor	r27, r27
     604:	8e 3a       	cpi	r24, 0xAE	; 174
     606:	91 45       	sbci	r25, 0x51	; 81
     608:	a1 05       	cpc	r26, r1
     60a:	b1 05       	cpc	r27, r1
     60c:	31 f4       	brne	.+12     	; 0x61a <DecodeCommand+0x52>
		InputState.currentState = DECREMENT;
     60e:	84 e0       	ldi	r24, 0x04	; 4
     610:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
		WriteInput();
     614:	7a df       	rcall	.-268    	; 0x50a <WriteInput>
		setState();
     616:	17 df       	rcall	.-466    	; 0x446 <setState>
		return;
     618:	08 95       	ret
	}
	else if ((command_register&0x0000FFFF)==IR_PLUS_bm){
     61a:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     61e:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     622:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     626:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     62a:	aa 27       	eor	r26, r26
     62c:	bb 27       	eor	r27, r27
     62e:	8e 35       	cpi	r24, 0x5E	; 94
     630:	91 4a       	sbci	r25, 0xA1	; 161
     632:	a1 05       	cpc	r26, r1
     634:	b1 05       	cpc	r27, r1
     636:	31 f4       	brne	.+12     	; 0x644 <DecodeCommand+0x7c>
		InputState.currentState = INCREMENT;
     638:	82 e0       	ldi	r24, 0x02	; 2
     63a:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
		WriteInput();
     63e:	65 df       	rcall	.-310    	; 0x50a <WriteInput>
		setState();
     640:	02 df       	rcall	.-508    	; 0x446 <setState>
		return;
     642:	08 95       	ret
	}
	else if((command_register&0x0000FFFF)==IR_LIGHT_bm){
     644:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     648:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     64c:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     650:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     654:	aa 27       	eor	r26, r26
     656:	bb 27       	eor	r27, r27
     658:	86 36       	cpi	r24, 0x66	; 102
     65a:	99 49       	sbci	r25, 0x99	; 153
     65c:	a1 05       	cpc	r26, r1
     65e:	b1 05       	cpc	r27, r1
     660:	21 f4       	brne	.+8      	; 0x66a <DecodeCommand+0xa2>
		InputState.currentState = LIGHT;
     662:	86 e0       	ldi	r24, 0x06	; 6
     664:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
		WriteInput();
     668:	50 df       	rcall	.-352    	; 0x50a <WriteInput>
     66a:	08 95       	ret

0000066c <IR_Read>:
state of the INPUT_STATE                                                                    */
/************************************************************************/
//IR Read function to decode incoming signal.
void IR_Read(){
	//If the signal is HIGH for 9ms, this means we are in START.
	switch(NECState.currentState){
     66c:	80 91 3e 3c 	lds	r24, 0x3C3E	; 0x803c3e <NECState>
     670:	82 30       	cpi	r24, 0x02	; 2
     672:	21 f0       	breq	.+8      	; 0x67c <IR_Read+0x10>
     674:	83 30       	cpi	r24, 0x03	; 3
     676:	09 f4       	brne	.+2      	; 0x67a <IR_Read+0xe>
     678:	f7 c1       	rjmp	.+1006   	; 0xa68 <IR_Read+0x3fc>
     67a:	08 95       	ret
			
		case(COMMAND):
		
			idle_flag=1;
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	80 93 26 3c 	sts	0x3C26, r24	; 0x803c26 <idle_flag>
     684:	90 93 27 3c 	sts	0x3C27, r25	; 0x803c27 <idle_flag+0x1>
			cli();
     688:	f8 94       	cli
			RTC.CNT = 0;
     68a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     68e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     692:	78 94       	sei
			//start timer
			
			disableIR_ISR();
     694:	72 de       	rcall	.-796    	; 0x37a <disableIR_ISR>
			while(((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 9000){
     696:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     69a:	83 fd       	sbrc	r24, 3
     69c:	10 c0       	rjmp	.+32     	; 0x6be <IR_Read+0x52>
     69e:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     6a2:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     6a6:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     6aa:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     6ae:	aa e7       	ldi	r26, 0x7A	; 122
     6b0:	b0 e0       	ldi	r27, 0x00	; 0
     6b2:	9d d4       	rcall	.+2362   	; 0xfee <__muluhisi3>
     6b4:	69 32       	cpi	r22, 0x29	; 41
     6b6:	73 42       	sbci	r23, 0x23	; 35
     6b8:	81 05       	cpc	r24, r1
     6ba:	91 05       	cpc	r25, r1
     6bc:	64 f3       	brlt	.-40     	; 0x696 <IR_Read+0x2a>
				
			}
			counter = 0;
     6be:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     6c2:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     6c6:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     6ca:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
			cli();
     6ce:	f8 94       	cli
			RTC.CNT = 0;
     6d0:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     6d4:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     6d8:	78 94       	sei
			
			while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 4500){
     6da:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     6de:	83 ff       	sbrs	r24, 3
     6e0:	10 c0       	rjmp	.+32     	; 0x702 <IR_Read+0x96>
     6e2:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     6e6:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     6ea:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     6ee:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     6f2:	aa e7       	ldi	r26, 0x7A	; 122
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	7b d4       	rcall	.+2294   	; 0xfee <__muluhisi3>
     6f8:	65 39       	cpi	r22, 0x95	; 149
     6fa:	71 41       	sbci	r23, 0x11	; 17
     6fc:	81 05       	cpc	r24, r1
     6fe:	91 05       	cpc	r25, r1
     700:	64 f3       	brlt	.-40     	; 0x6da <IR_Read+0x6e>
				
			}
			if(counter*RTC_TICK <= 2300){
     702:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     706:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     70a:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     70e:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     712:	aa e7       	ldi	r26, 0x7A	; 122
     714:	b0 e0       	ldi	r27, 0x00	; 0
     716:	6b d4       	rcall	.+2262   	; 0xfee <__muluhisi3>
     718:	6d 3f       	cpi	r22, 0xFD	; 253
     71a:	78 40       	sbci	r23, 0x08	; 8
     71c:	81 05       	cpc	r24, r1
     71e:	91 05       	cpc	r25, r1
     720:	0c f0       	brlt	.+2      	; 0x724 <IR_Read+0xb8>
     722:	41 c0       	rjmp	.+130    	; 0x7a6 <IR_Read+0x13a>
				//Repeat Case
				counter = 0;
     724:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     728:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     72c:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     730:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
				disableRTC();//reset timer
     734:	31 de       	rcall	.-926    	; 0x398 <disableRTC>
				enableRTC();
     736:	40 de       	rcall	.-896    	; 0x3b8 <enableRTC>
				cli();
     738:	f8 94       	cli
				RTC.CNT = 0;
     73a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     73e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     742:	78 94       	sei
				counter = 0;
     744:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     748:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     74c:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     750:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
				while(((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 600){
     754:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     758:	83 fd       	sbrc	r24, 3
     75a:	10 c0       	rjmp	.+32     	; 0x77c <IR_Read+0x110>
     75c:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     760:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     764:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     768:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     76c:	aa e7       	ldi	r26, 0x7A	; 122
     76e:	b0 e0       	ldi	r27, 0x00	; 0
     770:	3e d4       	rcall	.+2172   	; 0xfee <__muluhisi3>
     772:	69 35       	cpi	r22, 0x59	; 89
     774:	72 40       	sbci	r23, 0x02	; 2
     776:	81 05       	cpc	r24, r1
     778:	91 05       	cpc	r25, r1
     77a:	64 f3       	brlt	.-40     	; 0x754 <IR_Read+0xe8>
					//end of message
				}
				
				GenerateRepeatCode();
     77c:	d1 dd       	rcall	.-1118   	; 0x320 <GenerateRepeatCode>
				
				counter=0;
     77e:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     782:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     786:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     78a:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
				idle_flag=0;
     78e:	10 92 26 3c 	sts	0x3C26, r1	; 0x803c26 <idle_flag>
     792:	10 92 27 3c 	sts	0x3C27, r1	; 0x803c27 <idle_flag+0x1>
				cli();
     796:	f8 94       	cli
				RTC.CNT = 0;
     798:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     79c:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     7a0:	78 94       	sei
				
				enableIR_ISR();
     7a2:	f0 dd       	rcall	.-1056   	; 0x384 <enableIR_ISR>
				break;
     7a4:	08 95       	ret
			}
			
			//hold_counter = 0; // Reset hold counter if not received repeat signal.
			cli();
     7a6:	f8 94       	cli
			RTC.CNT = 0;
     7a8:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     7ac:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     7b0:	78 94       	sei
			counter = 0;
     7b2:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     7b6:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     7ba:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     7be:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
			idle_flag=0;
     7c2:	10 92 26 3c 	sts	0x3C26, r1	; 0x803c26 <idle_flag>
     7c6:	10 92 27 3c 	sts	0x3C27, r1	; 0x803c27 <idle_flag+0x1>
			command_counter_flag=1;
     7ca:	81 e0       	ldi	r24, 0x01	; 1
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	80 93 24 3c 	sts	0x3C24, r24	; 0x803c24 <command_counter_flag>
     7d2:	90 93 25 3c 	sts	0x3C25, r25	; 0x803c25 <command_counter_flag+0x1>
			for(i=0;i<33;i++){
     7d6:	10 92 3b 3c 	sts	0x3C3B, r1	; 0x803c3b <i>
     7da:	10 92 3c 3c 	sts	0x3C3C, r1	; 0x803c3c <i+0x1>
     7de:	ca c0       	rjmp	.+404    	; 0x974 <IR_Read+0x308>
				tick_counter=0;
     7e0:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <tick_counter>
     7e4:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <tick_counter+0x1>
     7e8:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <tick_counter+0x2>
     7ec:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <tick_counter+0x3>
				while(((PORTA.IN & (1<<IR_INPUT)) == 0)&&tick_counter*RTC_TICK<=650){
     7f0:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     7f4:	83 fd       	sbrc	r24, 3
     7f6:	10 c0       	rjmp	.+32     	; 0x818 <IR_Read+0x1ac>
     7f8:	20 91 20 3c 	lds	r18, 0x3C20	; 0x803c20 <tick_counter>
     7fc:	30 91 21 3c 	lds	r19, 0x3C21	; 0x803c21 <tick_counter+0x1>
     800:	40 91 22 3c 	lds	r20, 0x3C22	; 0x803c22 <tick_counter+0x2>
     804:	50 91 23 3c 	lds	r21, 0x3C23	; 0x803c23 <tick_counter+0x3>
     808:	aa e7       	ldi	r26, 0x7A	; 122
     80a:	b0 e0       	ldi	r27, 0x00	; 0
     80c:	f0 d3       	rcall	.+2016   	; 0xfee <__muluhisi3>
     80e:	6b 38       	cpi	r22, 0x8B	; 139
     810:	72 40       	sbci	r23, 0x02	; 2
     812:	81 05       	cpc	r24, r1
     814:	91 05       	cpc	r25, r1
     816:	64 f3       	brlt	.-40     	; 0x7f0 <IR_Read+0x184>
					//loop until next space
				}
				
				tick_counter=0;
     818:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <tick_counter>
     81c:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <tick_counter+0x1>
     820:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <tick_counter+0x2>
     824:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <tick_counter+0x3>
				disableRTC();//reset timer
     828:	b7 dd       	rcall	.-1170   	; 0x398 <disableRTC>
				enableRTC();
     82a:	c6 dd       	rcall	.-1140   	; 0x3b8 <enableRTC>
				while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&&tick_counter*RTC_TICK<=1800){
     82c:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     830:	83 ff       	sbrs	r24, 3
     832:	10 c0       	rjmp	.+32     	; 0x854 <IR_Read+0x1e8>
     834:	20 91 20 3c 	lds	r18, 0x3C20	; 0x803c20 <tick_counter>
     838:	30 91 21 3c 	lds	r19, 0x3C21	; 0x803c21 <tick_counter+0x1>
     83c:	40 91 22 3c 	lds	r20, 0x3C22	; 0x803c22 <tick_counter+0x2>
     840:	50 91 23 3c 	lds	r21, 0x3C23	; 0x803c23 <tick_counter+0x3>
     844:	aa e7       	ldi	r26, 0x7A	; 122
     846:	b0 e0       	ldi	r27, 0x00	; 0
     848:	d2 d3       	rcall	.+1956   	; 0xfee <__muluhisi3>
     84a:	69 30       	cpi	r22, 0x09	; 9
     84c:	77 40       	sbci	r23, 0x07	; 7
     84e:	81 05       	cpc	r24, r1
     850:	91 05       	cpc	r25, r1
     852:	64 f3       	brlt	.-40     	; 0x82c <IR_Read+0x1c0>
					//loop until next pulse
				}
				if(i==32 && tick_counter*RTC_TICK> 1000){//end of message
     854:	80 91 3b 3c 	lds	r24, 0x3C3B	; 0x803c3b <i>
     858:	90 91 3c 3c 	lds	r25, 0x3C3C	; 0x803c3c <i+0x1>
     85c:	80 97       	sbiw	r24, 0x20	; 32
     85e:	89 f4       	brne	.+34     	; 0x882 <IR_Read+0x216>
     860:	20 91 20 3c 	lds	r18, 0x3C20	; 0x803c20 <tick_counter>
     864:	30 91 21 3c 	lds	r19, 0x3C21	; 0x803c21 <tick_counter+0x1>
     868:	40 91 22 3c 	lds	r20, 0x3C22	; 0x803c22 <tick_counter+0x2>
     86c:	50 91 23 3c 	lds	r21, 0x3C23	; 0x803c23 <tick_counter+0x3>
     870:	aa e7       	ldi	r26, 0x7A	; 122
     872:	b0 e0       	ldi	r27, 0x00	; 0
     874:	bc d3       	rcall	.+1912   	; 0xfee <__muluhisi3>
     876:	69 3e       	cpi	r22, 0xE9	; 233
     878:	73 40       	sbci	r23, 0x03	; 3
     87a:	81 05       	cpc	r24, r1
     87c:	91 05       	cpc	r25, r1
     87e:	0c f0       	brlt	.+2      	; 0x882 <IR_Read+0x216>
     880:	80 c0       	rjmp	.+256    	; 0x982 <IR_Read+0x316>
					break;
				}
				if( tick_counter*RTC_TICK> 1000)   {                            
     882:	20 91 20 3c 	lds	r18, 0x3C20	; 0x803c20 <tick_counter>
     886:	30 91 21 3c 	lds	r19, 0x3C21	; 0x803c21 <tick_counter+0x1>
     88a:	40 91 22 3c 	lds	r20, 0x3C22	; 0x803c22 <tick_counter+0x2>
     88e:	50 91 23 3c 	lds	r21, 0x3C23	; 0x803c23 <tick_counter+0x3>
     892:	aa e7       	ldi	r26, 0x7A	; 122
     894:	b0 e0       	ldi	r27, 0x00	; 0
     896:	ab d3       	rcall	.+1878   	; 0xfee <__muluhisi3>
     898:	69 3e       	cpi	r22, 0xE9	; 233
     89a:	73 40       	sbci	r23, 0x03	; 3
     89c:	81 05       	cpc	r24, r1
     89e:	91 05       	cpc	r25, r1
     8a0:	b4 f1       	brlt	.+108    	; 0x90e <IR_Read+0x2a2>
					command_register = command_register<<1;   
     8a2:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     8a6:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     8aa:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     8ae:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     8b2:	88 0f       	add	r24, r24
     8b4:	99 1f       	adc	r25, r25
     8b6:	aa 1f       	adc	r26, r26
     8b8:	bb 1f       	adc	r27, r27
     8ba:	80 93 1a 3c 	sts	0x3C1A, r24	; 0x803c1a <command_register>
     8be:	90 93 1b 3c 	sts	0x3C1B, r25	; 0x803c1b <command_register+0x1>
     8c2:	a0 93 1c 3c 	sts	0x3C1C, r26	; 0x803c1c <command_register+0x2>
     8c6:	b0 93 1d 3c 	sts	0x3C1D, r27	; 0x803c1d <command_register+0x3>
					command_register |= 0x01;
     8ca:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     8ce:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     8d2:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     8d6:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     8da:	81 60       	ori	r24, 0x01	; 1
     8dc:	80 93 1a 3c 	sts	0x3C1A, r24	; 0x803c1a <command_register>
     8e0:	90 93 1b 3c 	sts	0x3C1B, r25	; 0x803c1b <command_register+0x1>
     8e4:	a0 93 1c 3c 	sts	0x3C1C, r26	; 0x803c1c <command_register+0x2>
     8e8:	b0 93 1d 3c 	sts	0x3C1D, r27	; 0x803c1d <command_register+0x3>
					tick_counter=tick_counter;
     8ec:	80 91 20 3c 	lds	r24, 0x3C20	; 0x803c20 <tick_counter>
     8f0:	90 91 21 3c 	lds	r25, 0x3C21	; 0x803c21 <tick_counter+0x1>
     8f4:	a0 91 22 3c 	lds	r26, 0x3C22	; 0x803c22 <tick_counter+0x2>
     8f8:	b0 91 23 3c 	lds	r27, 0x3C23	; 0x803c23 <tick_counter+0x3>
     8fc:	80 93 20 3c 	sts	0x3C20, r24	; 0x803c20 <tick_counter>
     900:	90 93 21 3c 	sts	0x3C21, r25	; 0x803c21 <tick_counter+0x1>
     904:	a0 93 22 3c 	sts	0x3C22, r26	; 0x803c22 <tick_counter+0x2>
     908:	b0 93 23 3c 	sts	0x3C23, r27	; 0x803c23 <tick_counter+0x3>
     90c:	24 c0       	rjmp	.+72     	; 0x956 <IR_Read+0x2ea>
				    }                
				else    {                                         
					command_register = command_register<<1;
     90e:	80 91 1a 3c 	lds	r24, 0x3C1A	; 0x803c1a <command_register>
     912:	90 91 1b 3c 	lds	r25, 0x3C1B	; 0x803c1b <command_register+0x1>
     916:	a0 91 1c 3c 	lds	r26, 0x3C1C	; 0x803c1c <command_register+0x2>
     91a:	b0 91 1d 3c 	lds	r27, 0x3C1D	; 0x803c1d <command_register+0x3>
     91e:	88 0f       	add	r24, r24
     920:	99 1f       	adc	r25, r25
     922:	aa 1f       	adc	r26, r26
     924:	bb 1f       	adc	r27, r27
     926:	80 93 1a 3c 	sts	0x3C1A, r24	; 0x803c1a <command_register>
     92a:	90 93 1b 3c 	sts	0x3C1B, r25	; 0x803c1b <command_register+0x1>
     92e:	a0 93 1c 3c 	sts	0x3C1C, r26	; 0x803c1c <command_register+0x2>
     932:	b0 93 1d 3c 	sts	0x3C1D, r27	; 0x803c1d <command_register+0x3>
					tick_counter=tick_counter;
     936:	80 91 20 3c 	lds	r24, 0x3C20	; 0x803c20 <tick_counter>
     93a:	90 91 21 3c 	lds	r25, 0x3C21	; 0x803c21 <tick_counter+0x1>
     93e:	a0 91 22 3c 	lds	r26, 0x3C22	; 0x803c22 <tick_counter+0x2>
     942:	b0 91 23 3c 	lds	r27, 0x3C23	; 0x803c23 <tick_counter+0x3>
     946:	80 93 20 3c 	sts	0x3C20, r24	; 0x803c20 <tick_counter>
     94a:	90 93 21 3c 	sts	0x3C21, r25	; 0x803c21 <tick_counter+0x1>
     94e:	a0 93 22 3c 	sts	0x3C22, r26	; 0x803c22 <tick_counter+0x2>
     952:	b0 93 23 3c 	sts	0x3C23, r27	; 0x803c23 <tick_counter+0x3>
				}
				
				
				cli();
     956:	f8 94       	cli
				RTC.CNT = 0;
     958:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     95c:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
				sei();
     960:	78 94       	sei
			RTC.CNT = 0;
			sei();
			counter = 0;
			idle_flag=0;
			command_counter_flag=1;
			for(i=0;i<33;i++){
     962:	80 91 3b 3c 	lds	r24, 0x3C3B	; 0x803c3b <i>
     966:	90 91 3c 3c 	lds	r25, 0x3C3C	; 0x803c3c <i+0x1>
     96a:	01 96       	adiw	r24, 0x01	; 1
     96c:	80 93 3b 3c 	sts	0x3C3B, r24	; 0x803c3b <i>
     970:	90 93 3c 3c 	sts	0x3C3C, r25	; 0x803c3c <i+0x1>
     974:	80 91 3b 3c 	lds	r24, 0x3C3B	; 0x803c3b <i>
     978:	90 91 3c 3c 	lds	r25, 0x3C3C	; 0x803c3c <i+0x1>
     97c:	81 97       	sbiw	r24, 0x21	; 33
     97e:	0c f4       	brge	.+2      	; 0x982 <IR_Read+0x316>
     980:	2f cf       	rjmp	.-418    	; 0x7e0 <IR_Read+0x174>
			}
			//wait for end bit. It is a inverse pulse for 500 us
			//If any signal comes in 40ms it is repeat
			//If not go to idle case.
			
			if(VerifyAddress()){
     982:	bc dc       	rcall	.-1672   	; 0x2fc <VerifyAddress>
     984:	81 11       	cpse	r24, r1
				DecodeCommand();
     986:	20 de       	rcall	.-960    	; 0x5c8 <DecodeCommand>
			}
			
			idle_flag=1;
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	80 93 26 3c 	sts	0x3C26, r24	; 0x803c26 <idle_flag>
     990:	90 93 27 3c 	sts	0x3C27, r25	; 0x803c27 <idle_flag+0x1>
			counter = 0;
     994:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     998:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     99c:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     9a0:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
			cli();
     9a4:	f8 94       	cli
			RTC.CNT = 0;
     9a6:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     9aa:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     9ae:	78 94       	sei
			//If we did not received messages for more than 100 ms, it means no repeat. Change flag
			while(!((PORTA.IN & (1<<IR_INPUT)) == 0)&& counter*RTC_TICK <= 50000){
     9b0:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7fc408>
     9b4:	83 ff       	sbrs	r24, 3
     9b6:	10 c0       	rjmp	.+32     	; 0x9d8 <IR_Read+0x36c>
     9b8:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     9bc:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     9c0:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     9c4:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     9c8:	aa e7       	ldi	r26, 0x7A	; 122
     9ca:	b0 e0       	ldi	r27, 0x00	; 0
     9cc:	10 d3       	rcall	.+1568   	; 0xfee <__muluhisi3>
     9ce:	61 35       	cpi	r22, 0x51	; 81
     9d0:	73 4c       	sbci	r23, 0xC3	; 195
     9d2:	81 05       	cpc	r24, r1
     9d4:	91 05       	cpc	r25, r1
     9d6:	64 f3       	brlt	.-40     	; 0x9b0 <IR_Read+0x344>
				
			}
			if(counter*RTC_TICK >= 40000){
     9d8:	20 91 28 3c 	lds	r18, 0x3C28	; 0x803c28 <counter>
     9dc:	30 91 29 3c 	lds	r19, 0x3C29	; 0x803c29 <counter+0x1>
     9e0:	40 91 2a 3c 	lds	r20, 0x3C2A	; 0x803c2a <counter+0x2>
     9e4:	50 91 2b 3c 	lds	r21, 0x3C2B	; 0x803c2b <counter+0x3>
     9e8:	aa e7       	ldi	r26, 0x7A	; 122
     9ea:	b0 e0       	ldi	r27, 0x00	; 0
     9ec:	00 d3       	rcall	.+1536   	; 0xfee <__muluhisi3>
     9ee:	60 34       	cpi	r22, 0x40	; 64
     9f0:	7c 49       	sbci	r23, 0x9C	; 156
     9f2:	81 05       	cpc	r24, r1
     9f4:	91 05       	cpc	r25, r1
     9f6:	24 f1       	brlt	.+72     	; 0xa40 <IR_Read+0x3d4>
				
				
				hold_flag=0;
     9f8:	10 92 14 3c 	sts	0x3C14, r1	; 0x803c14 <hold_flag>
     9fc:	10 92 15 3c 	sts	0x3C15, r1	; 0x803c15 <hold_flag+0x1>
				hold_counter = 0;
     a00:	10 92 16 3c 	sts	0x3C16, r1	; 0x803c16 <hold_counter>
     a04:	10 92 17 3c 	sts	0x3C17, r1	; 0x803c17 <hold_counter+0x1>
     a08:	10 92 18 3c 	sts	0x3C18, r1	; 0x803c18 <hold_counter+0x2>
     a0c:	10 92 19 3c 	sts	0x3C19, r1	; 0x803c19 <hold_counter+0x3>
				if(InputState.currentState==POWER_HOLD){
     a10:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     a14:	81 30       	cpi	r24, 0x01	; 1
     a16:	19 f4       	brne	.+6      	; 0xa1e <IR_Read+0x3b2>
					InputState.currentState=POWER;
     a18:	10 92 39 3c 	sts	0x3C39, r1	; 0x803c39 <InputState>
     a1c:	11 c0       	rjmp	.+34     	; 0xa40 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==INCREMENT_HOLD){
     a1e:	83 30       	cpi	r24, 0x03	; 3
     a20:	21 f4       	brne	.+8      	; 0xa2a <IR_Read+0x3be>
					InputState.currentState=INCREMENT;
     a22:	82 e0       	ldi	r24, 0x02	; 2
     a24:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     a28:	0b c0       	rjmp	.+22     	; 0xa40 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==DECREMENT_HOLD){
     a2a:	85 30       	cpi	r24, 0x05	; 5
     a2c:	21 f4       	brne	.+8      	; 0xa36 <IR_Read+0x3ca>
					InputState.currentState=DECREMENT;
     a2e:	84 e0       	ldi	r24, 0x04	; 4
     a30:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
     a34:	05 c0       	rjmp	.+10     	; 0xa40 <IR_Read+0x3d4>
				}
				else if(InputState.currentState==LIGHT_HOLD){
     a36:	87 30       	cpi	r24, 0x07	; 7
     a38:	19 f4       	brne	.+6      	; 0xa40 <IR_Read+0x3d4>
					InputState.currentState=LIGHT;
     a3a:	86 e0       	ldi	r24, 0x06	; 6
     a3c:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
				}
			}
			idle_flag=0;
     a40:	10 92 26 3c 	sts	0x3C26, r1	; 0x803c26 <idle_flag>
     a44:	10 92 27 3c 	sts	0x3C27, r1	; 0x803c27 <idle_flag+0x1>
			tick_counter=0;
     a48:	10 92 20 3c 	sts	0x3C20, r1	; 0x803c20 <tick_counter>
     a4c:	10 92 21 3c 	sts	0x3C21, r1	; 0x803c21 <tick_counter+0x1>
     a50:	10 92 22 3c 	sts	0x3C22, r1	; 0x803c22 <tick_counter+0x2>
     a54:	10 92 23 3c 	sts	0x3C23, r1	; 0x803c23 <tick_counter+0x3>
			cli();
     a58:	f8 94       	cli
			RTC.CNT = 0;
     a5a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__RODATA_PM_OFFSET__+0x7fc148>
     a5e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <__RODATA_PM_OFFSET__+0x7fc149>
			sei();
     a62:	78 94       	sei
			
			enableIR_ISR();
     a64:	8f dc       	rcall	.-1762   	; 0x384 <enableIR_ISR>
			//disable timer in the end
			break;
     a66:	08 95       	ret
		
		case(END):
			counter=0;
     a68:	10 92 28 3c 	sts	0x3C28, r1	; 0x803c28 <counter>
     a6c:	10 92 29 3c 	sts	0x3C29, r1	; 0x803c29 <counter+0x1>
     a70:	10 92 2a 3c 	sts	0x3C2A, r1	; 0x803c2a <counter+0x2>
     a74:	10 92 2b 3c 	sts	0x3C2B, r1	; 0x803c2b <counter+0x3>
     a78:	08 95       	ret

00000a7a <init_CLK>:
void init_CLK(){
	CCP = 0xD8;
     a7a:	88 ed       	ldi	r24, 0xD8	; 216
     a7c:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKLOCK =0x00;
     a7e:	e0 e6       	ldi	r30, 0x60	; 96
     a80:	f0 e0       	ldi	r31, 0x00	; 0
     a82:	12 82       	std	Z+2, r1	; 0x02
	CCP = 0xD8;
     a84:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB = 0;
     a86:	11 82       	std	Z+1, r1	; 0x01
	CCP = 0xD8;
     a88:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKLOCK =0x01;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	82 83       	std	Z+2, r24	; 0x02
     a8e:	08 95       	ret

00000a90 <init_LED>:
}

void init_LED(){
	//Initialize LEDs
	PORTA.DIR = (1<<LED_1) | (1<<LED_2) | (1<<LED_3) | (1<<LED_4) ;
     a90:	e0 e0       	ldi	r30, 0x00	; 0
     a92:	f4 e0       	ldi	r31, 0x04	; 4
     a94:	87 e2       	ldi	r24, 0x27	; 39
     a96:	80 83       	st	Z, r24
	PORTA.OUT = 0xFF; // Close All LEDs
     a98:	8f ef       	ldi	r24, 0xFF	; 255
     a9a:	84 83       	std	Z+4, r24	; 0x04
     a9c:	08 95       	ret

00000a9e <init_Motor>:
}
void init_Motor(){
	//Initialize Motors
	PORTD.DIR = (1<<MOTOR_RELAY_1) | (1<<MOTOR_RELAY_2)  |(1<<MOTOR_RELAY_3) |(1<<MOTOR_RELAY_4);
     a9e:	e0 e6       	ldi	r30, 0x60	; 96
     aa0:	f4 e0       	ldi	r31, 0x04	; 4
     aa2:	84 e7       	ldi	r24, 0x74	; 116
     aa4:	80 83       	st	Z, r24
	PORTD.OUT = 0x00; //Close all motors
     aa6:	14 82       	std	Z+4, r1	; 0x04
     aa8:	08 95       	ret

00000aaa <init_Buzzer>:
}
void init_Buzzer(){
		PORTD.DIR |= (1<<BUZZER);
     aaa:	e0 e6       	ldi	r30, 0x60	; 96
     aac:	f4 e0       	ldi	r31, 0x04	; 4
     aae:	80 81       	ld	r24, Z
     ab0:	80 68       	ori	r24, 0x80	; 128
     ab2:	80 83       	st	Z, r24
		PORTD.OUT &= ~(1<<BUZZER);
     ab4:	84 81       	ldd	r24, Z+4	; 0x04
     ab6:	8f 77       	andi	r24, 0x7F	; 127
     ab8:	84 83       	std	Z+4, r24	; 0x04
     aba:	08 95       	ret

00000abc <init_IR>:
}
void init_IR(){
	//Initialize IR Receiver
	PORTA.DIR &= ~(1<<IR_INPUT);	
     abc:	e0 e0       	ldi	r30, 0x00	; 0
     abe:	f4 e0       	ldi	r31, 0x04	; 4
     ac0:	80 81       	ld	r24, Z
     ac2:	87 7f       	andi	r24, 0xF7	; 247
     ac4:	80 83       	st	Z, r24
	PORTA.PIN3CTRL |= 0b00000011; //SET ISC to 0x3 to have falling edge trigger. ISC is last 3 bits. Set to 011.
     ac6:	83 89       	ldd	r24, Z+19	; 0x13
     ac8:	83 60       	ori	r24, 0x03	; 3
     aca:	83 8b       	std	Z+19, r24	; 0x13
     acc:	08 95       	ret

00000ace <init_RTC>:
}
void init_RTC(){
	//RTC initialize
	RTC.CLKSEL = RTC_CLKSEL_INT32K_gc;//32.768 kHz RTC
     ace:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <__RODATA_PM_OFFSET__+0x7fc147>
	while (RTC.STATUS > 0);//wait until status OK
     ad2:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <__RODATA_PM_OFFSET__+0x7fc141>
     ad6:	81 11       	cpse	r24, r1
     ad8:	fc cf       	rjmp	.-8      	; 0xad2 <init_RTC+0x4>
	RTC.PER = 4;  // 122 us per tick
     ada:	e0 e4       	ldi	r30, 0x40	; 64
     adc:	f1 e0       	ldi	r31, 0x01	; 1
     ade:	84 e0       	ldi	r24, 0x04	; 4
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	82 87       	std	Z+10, r24	; 0x0a
     ae4:	93 87       	std	Z+11, r25	; 0x0b
	RTC.INTCTRL |= RTC_OVF_bm;
     ae6:	82 81       	ldd	r24, Z+2	; 0x02
     ae8:	81 60       	ori	r24, 0x01	; 1
     aea:	82 83       	std	Z+2, r24	; 0x02
	RTC.CTRLA = RTC_PRESCALER_DIV1_gc|RTC_RTCEN_bm | RTC_RUNSTDBY_bm;
     aec:	81 e8       	ldi	r24, 0x81	; 129
     aee:	80 83       	st	Z, r24
	CPUINT.LVL1VEC = RTC_CNT_vect_num;//Give priority to RTC Interrupt
     af0:	83 e0       	ldi	r24, 0x03	; 3
     af2:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__RODATA_PM_OFFSET__+0x7fc113>
     af6:	08 95       	ret

00000af8 <init_Lights>:
}
void init_Lights(){
	PORTD.DIR = (1<<LED_ON_OFF);
     af8:	e0 e6       	ldi	r30, 0x60	; 96
     afa:	f4 e0       	ldi	r31, 0x04	; 4
     afc:	82 e0       	ldi	r24, 0x02	; 2
     afe:	80 83       	st	Z, r24
	PORTD.OUT = 0x00; // Close All LEDs
     b00:	14 82       	std	Z+4, r1	; 0x04
     b02:	08 95       	ret

00000b04 <Initialize>:
}
void Initialize(){
	
	init_CLK();
     b04:	ba df       	rcall	.-140    	; 0xa7a <init_CLK>
	init_LED();
     b06:	c4 df       	rcall	.-120    	; 0xa90 <init_LED>
	init_Motor();
     b08:	ca df       	rcall	.-108    	; 0xa9e <init_Motor>
	
	init_IR();
     b0a:	d8 df       	rcall	.-80     	; 0xabc <init_IR>
	init_Lights();
     b0c:	f5 df       	rcall	.-22     	; 0xaf8 <init_Lights>
	init_Buzzer();
     b0e:	cd df       	rcall	.-102    	; 0xaaa <init_Buzzer>
	SREG |= (1<<GLOBAL_INT_ENABLE); //Enable Interrupts
     b10:	8f b7       	in	r24, 0x3f	; 63
     b12:	80 68       	ori	r24, 0x80	; 128
     b14:	8f bf       	out	0x3f, r24	; 63
	 /* Enable Global Interrupts */
	

	//Initial state
	State.currentState = OFF;
     b16:	10 92 3d 3c 	sts	0x3C3D, r1	; 0x803c3d <State>
	LightState.currentState = OFF;
     b1a:	10 92 38 3c 	sts	0x3C38, r1	; 0x803c38 <LightState>
	NECState.currentState = IDLE;
     b1e:	10 92 3e 3c 	sts	0x3C3E, r1	; 0x803c3e <NECState>
	InputState.currentState = INITIAL_STATE;
     b22:	88 e0       	ldi	r24, 0x08	; 8
     b24:	80 93 39 3c 	sts	0x3C39, r24	; 0x803c39 <InputState>
	init_RTC();
     b28:	d2 df       	rcall	.-92     	; 0xace <init_RTC>
     b2a:	08 95       	ret

00000b2c <__vector_6>:
ISR(PORTA_PORT_vect){
     b2c:	1f 92       	push	r1
     b2e:	0f 92       	push	r0
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	0f 92       	push	r0
     b34:	11 24       	eor	r1, r1
     b36:	2f 93       	push	r18
     b38:	3f 93       	push	r19
     b3a:	4f 93       	push	r20
     b3c:	5f 93       	push	r21
     b3e:	6f 93       	push	r22
     b40:	7f 93       	push	r23
     b42:	8f 93       	push	r24
     b44:	9f 93       	push	r25
     b46:	af 93       	push	r26
     b48:	bf 93       	push	r27
     b4a:	ef 93       	push	r30
     b4c:	ff 93       	push	r31
	NECState.currentState = COMMAND;
     b4e:	82 e0       	ldi	r24, 0x02	; 2
     b50:	80 93 3e 3c 	sts	0x3C3E, r24	; 0x803c3e <NECState>
	IR_Read();
     b54:	8b dd       	rcall	.-1258   	; 0x66c <IR_Read>
}
     b56:	ff 91       	pop	r31
     b58:	ef 91       	pop	r30
     b5a:	bf 91       	pop	r27
     b5c:	af 91       	pop	r26
     b5e:	9f 91       	pop	r25
     b60:	8f 91       	pop	r24
     b62:	7f 91       	pop	r23
     b64:	6f 91       	pop	r22
     b66:	5f 91       	pop	r21
     b68:	4f 91       	pop	r20
     b6a:	3f 91       	pop	r19
     b6c:	2f 91       	pop	r18
     b6e:	0f 90       	pop	r0
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	0f 90       	pop	r0
     b74:	1f 90       	pop	r1
     b76:	18 95       	reti

00000b78 <__vector_3>:
ISR(RTC_CNT_vect){
     b78:	1f 92       	push	r1
     b7a:	0f 92       	push	r0
     b7c:	0f b6       	in	r0, 0x3f	; 63
     b7e:	0f 92       	push	r0
     b80:	11 24       	eor	r1, r1
     b82:	2f 93       	push	r18
     b84:	3f 93       	push	r19
     b86:	4f 93       	push	r20
     b88:	5f 93       	push	r21
     b8a:	6f 93       	push	r22
     b8c:	7f 93       	push	r23
     b8e:	8f 93       	push	r24
     b90:	9f 93       	push	r25
     b92:	af 93       	push	r26
     b94:	bf 93       	push	r27
     b96:	ef 93       	push	r30
     b98:	ff 93       	push	r31
	RTC.INTFLAGS = RTC_OVF_bm;
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__RODATA_PM_OFFSET__+0x7fc143>
	
	if(idle_flag == 1){
     ba0:	80 91 26 3c 	lds	r24, 0x3C26	; 0x803c26 <idle_flag>
     ba4:	90 91 27 3c 	lds	r25, 0x3C27	; 0x803c27 <idle_flag+0x1>
     ba8:	01 97       	sbiw	r24, 0x01	; 1
     baa:	99 f4       	brne	.+38     	; 0xbd2 <__vector_3+0x5a>
		counter++;
     bac:	80 91 28 3c 	lds	r24, 0x3C28	; 0x803c28 <counter>
     bb0:	90 91 29 3c 	lds	r25, 0x3C29	; 0x803c29 <counter+0x1>
     bb4:	a0 91 2a 3c 	lds	r26, 0x3C2A	; 0x803c2a <counter+0x2>
     bb8:	b0 91 2b 3c 	lds	r27, 0x3C2B	; 0x803c2b <counter+0x3>
     bbc:	01 96       	adiw	r24, 0x01	; 1
     bbe:	a1 1d       	adc	r26, r1
     bc0:	b1 1d       	adc	r27, r1
     bc2:	80 93 28 3c 	sts	0x3C28, r24	; 0x803c28 <counter>
     bc6:	90 93 29 3c 	sts	0x3C29, r25	; 0x803c29 <counter+0x1>
     bca:	a0 93 2a 3c 	sts	0x3C2A, r26	; 0x803c2a <counter+0x2>
     bce:	b0 93 2b 3c 	sts	0x3C2B, r27	; 0x803c2b <counter+0x3>
	}
	if(command_counter_flag==1){
     bd2:	80 91 24 3c 	lds	r24, 0x3C24	; 0x803c24 <command_counter_flag>
     bd6:	90 91 25 3c 	lds	r25, 0x3C25	; 0x803c25 <command_counter_flag+0x1>
     bda:	01 97       	sbiw	r24, 0x01	; 1
     bdc:	e1 f4       	brne	.+56     	; 0xc16 <__vector_3+0x9e>
		tick_counter++;
     bde:	80 91 20 3c 	lds	r24, 0x3C20	; 0x803c20 <tick_counter>
     be2:	90 91 21 3c 	lds	r25, 0x3C21	; 0x803c21 <tick_counter+0x1>
     be6:	a0 91 22 3c 	lds	r26, 0x3C22	; 0x803c22 <tick_counter+0x2>
     bea:	b0 91 23 3c 	lds	r27, 0x3C23	; 0x803c23 <tick_counter+0x3>
     bee:	01 96       	adiw	r24, 0x01	; 1
     bf0:	a1 1d       	adc	r26, r1
     bf2:	b1 1d       	adc	r27, r1
     bf4:	80 93 20 3c 	sts	0x3C20, r24	; 0x803c20 <tick_counter>
     bf8:	90 93 21 3c 	sts	0x3C21, r25	; 0x803c21 <tick_counter+0x1>
     bfc:	a0 93 22 3c 	sts	0x3C22, r26	; 0x803c22 <tick_counter+0x2>
     c00:	b0 93 23 3c 	sts	0x3C23, r27	; 0x803c23 <tick_counter+0x3>
		total_tick_counter++;
     c04:	80 91 1e 3c 	lds	r24, 0x3C1E	; 0x803c1e <total_tick_counter>
     c08:	90 91 1f 3c 	lds	r25, 0x3C1F	; 0x803c1f <total_tick_counter+0x1>
     c0c:	01 96       	adiw	r24, 0x01	; 1
     c0e:	80 93 1e 3c 	sts	0x3C1E, r24	; 0x803c1e <total_tick_counter>
     c12:	90 93 1f 3c 	sts	0x3C1F, r25	; 0x803c1f <total_tick_counter+0x1>
	}
	if(State.currentState==BOOST){
     c16:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	09 f0       	breq	.+2      	; 0xc20 <__vector_3+0xa8>
     c1e:	58 c0       	rjmp	.+176    	; 0xcd0 <__vector_3+0x158>
		boost_timer++;
     c20:	80 91 10 3c 	lds	r24, 0x3C10	; 0x803c10 <boost_timer>
     c24:	90 91 11 3c 	lds	r25, 0x3C11	; 0x803c11 <boost_timer+0x1>
     c28:	a0 91 12 3c 	lds	r26, 0x3C12	; 0x803c12 <boost_timer+0x2>
     c2c:	b0 91 13 3c 	lds	r27, 0x3C13	; 0x803c13 <boost_timer+0x3>
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	a1 1d       	adc	r26, r1
     c34:	b1 1d       	adc	r27, r1
     c36:	80 93 10 3c 	sts	0x3C10, r24	; 0x803c10 <boost_timer>
     c3a:	90 93 11 3c 	sts	0x3C11, r25	; 0x803c11 <boost_timer+0x1>
     c3e:	a0 93 12 3c 	sts	0x3C12, r26	; 0x803c12 <boost_timer+0x2>
     c42:	b0 93 13 3c 	sts	0x3C13, r27	; 0x803c13 <boost_timer+0x3>
		boost_total_timer++;
     c46:	80 91 0c 3c 	lds	r24, 0x3C0C	; 0x803c0c <boost_total_timer>
     c4a:	90 91 0d 3c 	lds	r25, 0x3C0D	; 0x803c0d <boost_total_timer+0x1>
     c4e:	a0 91 0e 3c 	lds	r26, 0x3C0E	; 0x803c0e <boost_total_timer+0x2>
     c52:	b0 91 0f 3c 	lds	r27, 0x3C0F	; 0x803c0f <boost_total_timer+0x3>
     c56:	01 96       	adiw	r24, 0x01	; 1
     c58:	a1 1d       	adc	r26, r1
     c5a:	b1 1d       	adc	r27, r1
     c5c:	80 93 0c 3c 	sts	0x3C0C, r24	; 0x803c0c <boost_total_timer>
     c60:	90 93 0d 3c 	sts	0x3C0D, r25	; 0x803c0d <boost_total_timer+0x1>
     c64:	a0 93 0e 3c 	sts	0x3C0E, r26	; 0x803c0e <boost_total_timer+0x2>
     c68:	b0 93 0f 3c 	sts	0x3C0F, r27	; 0x803c0f <boost_total_timer+0x3>
		if(boost_timer*RTC_TICK >= ONE_SEC){ // 1sec
     c6c:	20 91 10 3c 	lds	r18, 0x3C10	; 0x803c10 <boost_timer>
     c70:	30 91 11 3c 	lds	r19, 0x3C11	; 0x803c11 <boost_timer+0x1>
     c74:	40 91 12 3c 	lds	r20, 0x3C12	; 0x803c12 <boost_timer+0x2>
     c78:	50 91 13 3c 	lds	r21, 0x3C13	; 0x803c13 <boost_timer+0x3>
     c7c:	aa e7       	ldi	r26, 0x7A	; 122
     c7e:	b0 e0       	ldi	r27, 0x00	; 0
     c80:	b6 d1       	rcall	.+876    	; 0xfee <__muluhisi3>
     c82:	60 34       	cpi	r22, 0x40	; 64
     c84:	72 44       	sbci	r23, 0x42	; 66
     c86:	8f 40       	sbci	r24, 0x0F	; 15
     c88:	91 05       	cpc	r25, r1
     c8a:	70 f0       	brcs	.+28     	; 0xca8 <__vector_3+0x130>
			PORTA.OUT ^= (1<<LED_4);
     c8c:	e0 e0       	ldi	r30, 0x00	; 0
     c8e:	f4 e0       	ldi	r31, 0x04	; 4
     c90:	94 81       	ldd	r25, Z+4	; 0x04
     c92:	80 e2       	ldi	r24, 0x20	; 32
     c94:	89 27       	eor	r24, r25
     c96:	84 83       	std	Z+4, r24	; 0x04
			boost_timer=0;
     c98:	10 92 10 3c 	sts	0x3C10, r1	; 0x803c10 <boost_timer>
     c9c:	10 92 11 3c 	sts	0x3C11, r1	; 0x803c11 <boost_timer+0x1>
     ca0:	10 92 12 3c 	sts	0x3C12, r1	; 0x803c12 <boost_timer+0x2>
     ca4:	10 92 13 3c 	sts	0x3C13, r1	; 0x803c13 <boost_timer+0x3>
		}
		if(boost_total_timer*RTC_TICK>=BOOST_MAX_30SEC){
     ca8:	20 91 0c 3c 	lds	r18, 0x3C0C	; 0x803c0c <boost_total_timer>
     cac:	30 91 0d 3c 	lds	r19, 0x3C0D	; 0x803c0d <boost_total_timer+0x1>
     cb0:	40 91 0e 3c 	lds	r20, 0x3C0E	; 0x803c0e <boost_total_timer+0x2>
     cb4:	50 91 0f 3c 	lds	r21, 0x3C0F	; 0x803c0f <boost_total_timer+0x3>
     cb8:	aa e7       	ldi	r26, 0x7A	; 122
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	98 d1       	rcall	.+816    	; 0xfee <__muluhisi3>
     cbe:	60 38       	cpi	r22, 0x80	; 128
     cc0:	73 4c       	sbci	r23, 0xC3	; 195
     cc2:	89 4c       	sbci	r24, 0xC9	; 201
     cc4:	91 40       	sbci	r25, 0x01	; 1
     cc6:	20 f0       	brcs	.+8      	; 0xcd0 <__vector_3+0x158>
			State.currentState = THREE;
     cc8:	83 e0       	ldi	r24, 0x03	; 3
     cca:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
			setState();
     cce:	bb db       	rcall	.-2186   	; 0x446 <setState>
		}
	}
	if(hold_flag==1){
     cd0:	80 91 14 3c 	lds	r24, 0x3C14	; 0x803c14 <hold_flag>
     cd4:	90 91 15 3c 	lds	r25, 0x3C15	; 0x803c15 <hold_flag+0x1>
     cd8:	01 97       	sbiw	r24, 0x01	; 1
     cda:	09 f0       	breq	.+2      	; 0xcde <__vector_3+0x166>
     cdc:	8f c0       	rjmp	.+286    	; 0xdfc <__vector_3+0x284>
		hold_counter++;
     cde:	80 91 16 3c 	lds	r24, 0x3C16	; 0x803c16 <hold_counter>
     ce2:	90 91 17 3c 	lds	r25, 0x3C17	; 0x803c17 <hold_counter+0x1>
     ce6:	a0 91 18 3c 	lds	r26, 0x3C18	; 0x803c18 <hold_counter+0x2>
     cea:	b0 91 19 3c 	lds	r27, 0x3C19	; 0x803c19 <hold_counter+0x3>
     cee:	01 96       	adiw	r24, 0x01	; 1
     cf0:	a1 1d       	adc	r26, r1
     cf2:	b1 1d       	adc	r27, r1
     cf4:	80 93 16 3c 	sts	0x3C16, r24	; 0x803c16 <hold_counter>
     cf8:	90 93 17 3c 	sts	0x3C17, r25	; 0x803c17 <hold_counter+0x1>
     cfc:	a0 93 18 3c 	sts	0x3C18, r26	; 0x803c18 <hold_counter+0x2>
     d00:	b0 93 19 3c 	sts	0x3C19, r27	; 0x803c19 <hold_counter+0x3>
		if((hold_counter*RTC_TICK>=2*ONE_SEC) && InputState.currentState==POWER_HOLD){//After 4 sec power button press, indicate with buzzer and wait for 2 sec
     d04:	20 91 16 3c 	lds	r18, 0x3C16	; 0x803c16 <hold_counter>
     d08:	30 91 17 3c 	lds	r19, 0x3C17	; 0x803c17 <hold_counter+0x1>
     d0c:	40 91 18 3c 	lds	r20, 0x3C18	; 0x803c18 <hold_counter+0x2>
     d10:	50 91 19 3c 	lds	r21, 0x3C19	; 0x803c19 <hold_counter+0x3>
     d14:	aa e7       	ldi	r26, 0x7A	; 122
     d16:	b0 e0       	ldi	r27, 0x00	; 0
     d18:	6a d1       	rcall	.+724    	; 0xfee <__muluhisi3>
     d1a:	60 38       	cpi	r22, 0x80	; 128
     d1c:	74 48       	sbci	r23, 0x84	; 132
     d1e:	8e 41       	sbci	r24, 0x1E	; 30
     d20:	91 05       	cpc	r25, r1
     d22:	a0 f0       	brcs	.+40     	; 0xd4c <__vector_3+0x1d4>
     d24:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     d28:	81 30       	cpi	r24, 0x01	; 1
     d2a:	81 f4       	brne	.+32     	; 0xd4c <__vector_3+0x1d4>
			dev_mode_flag=1;
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	a0 e0       	ldi	r26, 0x00	; 0
     d32:	b0 e0       	ldi	r27, 0x00	; 0
     d34:	80 93 08 3c 	sts	0x3C08, r24	; 0x803c08 <dev_mode_flag>
     d38:	90 93 09 3c 	sts	0x3C09, r25	; 0x803c09 <dev_mode_flag+0x1>
     d3c:	a0 93 0a 3c 	sts	0x3C0A, r26	; 0x803c0a <dev_mode_flag+0x2>
     d40:	b0 93 0b 3c 	sts	0x3C0B, r27	; 0x803c0b <dev_mode_flag+0x3>
			BuzzerState.currentState = DEV_INIT_SOUND;
     d44:	85 e0       	ldi	r24, 0x05	; 5
     d46:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     d4a:	c2 d9       	rcall	.-3196   	; 0xd0 <Buzzer>
			
			
		}
		if((hold_counter*RTC_TICK>=2*ONE_SEC)&&InputState.currentState== LIGHT_HOLD&&dev_mode_flag==0){
     d4c:	20 91 16 3c 	lds	r18, 0x3C16	; 0x803c16 <hold_counter>
     d50:	30 91 17 3c 	lds	r19, 0x3C17	; 0x803c17 <hold_counter+0x1>
     d54:	40 91 18 3c 	lds	r20, 0x3C18	; 0x803c18 <hold_counter+0x2>
     d58:	50 91 19 3c 	lds	r21, 0x3C19	; 0x803c19 <hold_counter+0x3>
     d5c:	aa e7       	ldi	r26, 0x7A	; 122
     d5e:	b0 e0       	ldi	r27, 0x00	; 0
     d60:	46 d1       	rcall	.+652    	; 0xfee <__muluhisi3>
     d62:	60 38       	cpi	r22, 0x80	; 128
     d64:	74 48       	sbci	r23, 0x84	; 132
     d66:	8e 41       	sbci	r24, 0x1E	; 30
     d68:	91 05       	cpc	r25, r1
     d6a:	c0 f0       	brcs	.+48     	; 0xd9c <__vector_3+0x224>
     d6c:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     d70:	87 30       	cpi	r24, 0x07	; 7
     d72:	a1 f4       	brne	.+40     	; 0xd9c <__vector_3+0x224>
     d74:	80 91 08 3c 	lds	r24, 0x3C08	; 0x803c08 <dev_mode_flag>
     d78:	90 91 09 3c 	lds	r25, 0x3C09	; 0x803c09 <dev_mode_flag+0x1>
     d7c:	a0 91 0a 3c 	lds	r26, 0x3C0A	; 0x803c0a <dev_mode_flag+0x2>
     d80:	b0 91 0b 3c 	lds	r27, 0x3C0B	; 0x803c0b <dev_mode_flag+0x3>
     d84:	89 2b       	or	r24, r25
     d86:	8a 2b       	or	r24, r26
     d88:	8b 2b       	or	r24, r27
     d8a:	41 f4       	brne	.+16     	; 0xd9c <__vector_3+0x224>
			State.currentState = BRIGHT_ADJ;
     d8c:	86 e0       	ldi	r24, 0x06	; 6
     d8e:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
			BuzzerState.currentState = LIGHT_ADJ_SOUND;
     d92:	87 e0       	ldi	r24, 0x07	; 7
     d94:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     d98:	9b d9       	rcall	.-3274   	; 0xd0 <Buzzer>
			setState();
     d9a:	55 db       	rcall	.-2390   	; 0x446 <setState>
		}
		if((hold_counter*RTC_TICK>=1*ONE_SEC)&&InputState.currentState== LIGHT_HOLD&&dev_mode_flag==1){
     d9c:	20 91 16 3c 	lds	r18, 0x3C16	; 0x803c16 <hold_counter>
     da0:	30 91 17 3c 	lds	r19, 0x3C17	; 0x803c17 <hold_counter+0x1>
     da4:	40 91 18 3c 	lds	r20, 0x3C18	; 0x803c18 <hold_counter+0x2>
     da8:	50 91 19 3c 	lds	r21, 0x3C19	; 0x803c19 <hold_counter+0x3>
     dac:	aa e7       	ldi	r26, 0x7A	; 122
     dae:	b0 e0       	ldi	r27, 0x00	; 0
     db0:	1e d1       	rcall	.+572    	; 0xfee <__muluhisi3>
     db2:	60 34       	cpi	r22, 0x40	; 64
     db4:	72 44       	sbci	r23, 0x42	; 66
     db6:	8f 40       	sbci	r24, 0x0F	; 15
     db8:	91 05       	cpc	r25, r1
     dba:	00 f1       	brcs	.+64     	; 0xdfc <__vector_3+0x284>
     dbc:	80 91 39 3c 	lds	r24, 0x3C39	; 0x803c39 <InputState>
     dc0:	87 30       	cpi	r24, 0x07	; 7
     dc2:	e1 f4       	brne	.+56     	; 0xdfc <__vector_3+0x284>
     dc4:	80 91 08 3c 	lds	r24, 0x3C08	; 0x803c08 <dev_mode_flag>
     dc8:	90 91 09 3c 	lds	r25, 0x3C09	; 0x803c09 <dev_mode_flag+0x1>
     dcc:	a0 91 0a 3c 	lds	r26, 0x3C0A	; 0x803c0a <dev_mode_flag+0x2>
     dd0:	b0 91 0b 3c 	lds	r27, 0x3C0B	; 0x803c0b <dev_mode_flag+0x3>
     dd4:	01 97       	sbiw	r24, 0x01	; 1
     dd6:	a1 05       	cpc	r26, r1
     dd8:	b1 05       	cpc	r27, r1
     dda:	81 f4       	brne	.+32     	; 0xdfc <__vector_3+0x284>
			State.currentState = DEV_MODE;
     ddc:	85 e0       	ldi	r24, 0x05	; 5
     dde:	80 93 3d 3c 	sts	0x3C3D, r24	; 0x803c3d <State>
			BuzzerState.currentState = DEV_MODE_SOUND;
     de2:	86 e0       	ldi	r24, 0x06	; 6
     de4:	80 93 40 3c 	sts	0x3C40, r24	; 0x803c40 <BuzzerState>
			Buzzer();
     de8:	73 d9       	rcall	.-3354   	; 0xd0 <Buzzer>
			dev_mode_flag=0;
     dea:	10 92 08 3c 	sts	0x3C08, r1	; 0x803c08 <dev_mode_flag>
     dee:	10 92 09 3c 	sts	0x3C09, r1	; 0x803c09 <dev_mode_flag+0x1>
     df2:	10 92 0a 3c 	sts	0x3C0A, r1	; 0x803c0a <dev_mode_flag+0x2>
     df6:	10 92 0b 3c 	sts	0x3C0B, r1	; 0x803c0b <dev_mode_flag+0x3>
			//Close all lights at first;
			setState();
     dfa:	25 db       	rcall	.-2486   	; 0x446 <setState>
		}
	}
	if(BuzzerFlag==1){
     dfc:	80 91 34 3c 	lds	r24, 0x3C34	; 0x803c34 <BuzzerFlag>
     e00:	90 91 35 3c 	lds	r25, 0x3C35	; 0x803c35 <BuzzerFlag+0x1>
     e04:	a0 91 36 3c 	lds	r26, 0x3C36	; 0x803c36 <BuzzerFlag+0x2>
     e08:	b0 91 37 3c 	lds	r27, 0x3C37	; 0x803c37 <BuzzerFlag+0x3>
     e0c:	01 97       	sbiw	r24, 0x01	; 1
     e0e:	a1 05       	cpc	r26, r1
     e10:	b1 05       	cpc	r27, r1
     e12:	09 f0       	breq	.+2      	; 0xe16 <__vector_3+0x29e>
     e14:	62 c0       	rjmp	.+196    	; 0xeda <__vector_3+0x362>
		BuzzerCounter++;
     e16:	80 91 30 3c 	lds	r24, 0x3C30	; 0x803c30 <BuzzerCounter>
     e1a:	90 91 31 3c 	lds	r25, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     e1e:	a0 91 32 3c 	lds	r26, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     e22:	b0 91 33 3c 	lds	r27, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     e26:	01 96       	adiw	r24, 0x01	; 1
     e28:	a1 1d       	adc	r26, r1
     e2a:	b1 1d       	adc	r27, r1
     e2c:	80 93 30 3c 	sts	0x3C30, r24	; 0x803c30 <BuzzerCounter>
     e30:	90 93 31 3c 	sts	0x3C31, r25	; 0x803c31 <BuzzerCounter+0x1>
     e34:	a0 93 32 3c 	sts	0x3C32, r26	; 0x803c32 <BuzzerCounter+0x2>
     e38:	b0 93 33 3c 	sts	0x3C33, r27	; 0x803c33 <BuzzerCounter+0x3>
		PORTD.OUT |= (1<<BUZZER);
     e3c:	e0 e6       	ldi	r30, 0x60	; 96
     e3e:	f4 e0       	ldi	r31, 0x04	; 4
     e40:	84 81       	ldd	r24, Z+4	; 0x04
     e42:	80 68       	ori	r24, 0x80	; 128
     e44:	84 83       	std	Z+4, r24	; 0x04
		Buzzer();
     e46:	44 d9       	rcall	.-3448   	; 0xd0 <Buzzer>
		
		if(BuzzerCounter*RTC_TICK>=ONE_SEC/10){
     e48:	20 91 30 3c 	lds	r18, 0x3C30	; 0x803c30 <BuzzerCounter>
     e4c:	30 91 31 3c 	lds	r19, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     e50:	40 91 32 3c 	lds	r20, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     e54:	50 91 33 3c 	lds	r21, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     e58:	aa e7       	ldi	r26, 0x7A	; 122
     e5a:	b0 e0       	ldi	r27, 0x00	; 0
     e5c:	c8 d0       	rcall	.+400    	; 0xfee <__muluhisi3>
     e5e:	60 3a       	cpi	r22, 0xA0	; 160
     e60:	76 48       	sbci	r23, 0x86	; 134
     e62:	81 40       	sbci	r24, 0x01	; 1
     e64:	91 05       	cpc	r25, r1
     e66:	e8 f0       	brcs	.+58     	; 0xea2 <__vector_3+0x32a>
			BuzzerFlag=0;
     e68:	10 92 34 3c 	sts	0x3C34, r1	; 0x803c34 <BuzzerFlag>
     e6c:	10 92 35 3c 	sts	0x3C35, r1	; 0x803c35 <BuzzerFlag+0x1>
     e70:	10 92 36 3c 	sts	0x3C36, r1	; 0x803c36 <BuzzerFlag+0x2>
     e74:	10 92 37 3c 	sts	0x3C37, r1	; 0x803c37 <BuzzerFlag+0x3>
			BuzzerCounter=0;
     e78:	10 92 30 3c 	sts	0x3C30, r1	; 0x803c30 <BuzzerCounter>
     e7c:	10 92 31 3c 	sts	0x3C31, r1	; 0x803c31 <BuzzerCounter+0x1>
     e80:	10 92 32 3c 	sts	0x3C32, r1	; 0x803c32 <BuzzerCounter+0x2>
     e84:	10 92 33 3c 	sts	0x3C33, r1	; 0x803c33 <BuzzerCounter+0x3>
			Pitch_flag=0;
     e88:	10 92 2c 3c 	sts	0x3C2C, r1	; 0x803c2c <Pitch_flag>
     e8c:	10 92 2d 3c 	sts	0x3C2D, r1	; 0x803c2d <Pitch_flag+0x1>
     e90:	10 92 2e 3c 	sts	0x3C2E, r1	; 0x803c2e <Pitch_flag+0x2>
     e94:	10 92 2f 3c 	sts	0x3C2F, r1	; 0x803c2f <Pitch_flag+0x3>
			PORTD.OUT &= ~(1<<BUZZER);
     e98:	e0 e6       	ldi	r30, 0x60	; 96
     e9a:	f4 e0       	ldi	r31, 0x04	; 4
     e9c:	84 81       	ldd	r24, Z+4	; 0x04
     e9e:	8f 77       	andi	r24, 0x7F	; 127
     ea0:	84 83       	std	Z+4, r24	; 0x04
		}
		if(BuzzerCounter*RTC_TICK>=ONE_SEC/20){
     ea2:	20 91 30 3c 	lds	r18, 0x3C30	; 0x803c30 <BuzzerCounter>
     ea6:	30 91 31 3c 	lds	r19, 0x3C31	; 0x803c31 <BuzzerCounter+0x1>
     eaa:	40 91 32 3c 	lds	r20, 0x3C32	; 0x803c32 <BuzzerCounter+0x2>
     eae:	50 91 33 3c 	lds	r21, 0x3C33	; 0x803c33 <BuzzerCounter+0x3>
     eb2:	aa e7       	ldi	r26, 0x7A	; 122
     eb4:	b0 e0       	ldi	r27, 0x00	; 0
     eb6:	9b d0       	rcall	.+310    	; 0xfee <__muluhisi3>
     eb8:	60 35       	cpi	r22, 0x50	; 80
     eba:	73 4c       	sbci	r23, 0xC3	; 195
     ebc:	81 05       	cpc	r24, r1
     ebe:	91 05       	cpc	r25, r1
     ec0:	60 f0       	brcs	.+24     	; 0xeda <__vector_3+0x362>
			Pitch_flag=1;
     ec2:	81 e0       	ldi	r24, 0x01	; 1
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	a0 e0       	ldi	r26, 0x00	; 0
     ec8:	b0 e0       	ldi	r27, 0x00	; 0
     eca:	80 93 2c 3c 	sts	0x3C2C, r24	; 0x803c2c <Pitch_flag>
     ece:	90 93 2d 3c 	sts	0x3C2D, r25	; 0x803c2d <Pitch_flag+0x1>
     ed2:	a0 93 2e 3c 	sts	0x3C2E, r26	; 0x803c2e <Pitch_flag+0x2>
     ed6:	b0 93 2f 3c 	sts	0x3C2F, r27	; 0x803c2f <Pitch_flag+0x3>
		}
	}
	if(State.currentState==DEV_MODE){
     eda:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     ede:	85 30       	cpi	r24, 0x05	; 5
     ee0:	61 f5       	brne	.+88     	; 0xf3a <__vector_3+0x3c2>
		dev_mode_timer++;
     ee2:	80 91 04 3c 	lds	r24, 0x3C04	; 0x803c04 <dev_mode_timer>
     ee6:	90 91 05 3c 	lds	r25, 0x3C05	; 0x803c05 <dev_mode_timer+0x1>
     eea:	a0 91 06 3c 	lds	r26, 0x3C06	; 0x803c06 <dev_mode_timer+0x2>
     eee:	b0 91 07 3c 	lds	r27, 0x3C07	; 0x803c07 <dev_mode_timer+0x3>
     ef2:	01 96       	adiw	r24, 0x01	; 1
     ef4:	a1 1d       	adc	r26, r1
     ef6:	b1 1d       	adc	r27, r1
     ef8:	80 93 04 3c 	sts	0x3C04, r24	; 0x803c04 <dev_mode_timer>
     efc:	90 93 05 3c 	sts	0x3C05, r25	; 0x803c05 <dev_mode_timer+0x1>
     f00:	a0 93 06 3c 	sts	0x3C06, r26	; 0x803c06 <dev_mode_timer+0x2>
     f04:	b0 93 07 3c 	sts	0x3C07, r27	; 0x803c07 <dev_mode_timer+0x3>
		if(dev_mode_timer*RTC_TICK>=ONE_SEC){
     f08:	20 91 04 3c 	lds	r18, 0x3C04	; 0x803c04 <dev_mode_timer>
     f0c:	30 91 05 3c 	lds	r19, 0x3C05	; 0x803c05 <dev_mode_timer+0x1>
     f10:	40 91 06 3c 	lds	r20, 0x3C06	; 0x803c06 <dev_mode_timer+0x2>
     f14:	50 91 07 3c 	lds	r21, 0x3C07	; 0x803c07 <dev_mode_timer+0x3>
     f18:	aa e7       	ldi	r26, 0x7A	; 122
     f1a:	b0 e0       	ldi	r27, 0x00	; 0
     f1c:	68 d0       	rcall	.+208    	; 0xfee <__muluhisi3>
     f1e:	60 34       	cpi	r22, 0x40	; 64
     f20:	72 44       	sbci	r23, 0x42	; 66
     f22:	8f 40       	sbci	r24, 0x0F	; 15
     f24:	91 05       	cpc	r25, r1
     f26:	48 f0       	brcs	.+18     	; 0xf3a <__vector_3+0x3c2>
			dev_mode_timer=0;
     f28:	10 92 04 3c 	sts	0x3C04, r1	; 0x803c04 <dev_mode_timer>
     f2c:	10 92 05 3c 	sts	0x3C05, r1	; 0x803c05 <dev_mode_timer+0x1>
     f30:	10 92 06 3c 	sts	0x3C06, r1	; 0x803c06 <dev_mode_timer+0x2>
     f34:	10 92 07 3c 	sts	0x3C07, r1	; 0x803c07 <dev_mode_timer+0x3>
			setState();
     f38:	86 da       	rcall	.-2804   	; 0x446 <setState>
		}
	}
	if(State.currentState==BRIGHT_ADJ){
     f3a:	80 91 3d 3c 	lds	r24, 0x3C3D	; 0x803c3d <State>
     f3e:	86 30       	cpi	r24, 0x06	; 6
     f40:	39 f5       	brne	.+78     	; 0xf90 <__vector_3+0x418>
		bright_mode_counter++;
     f42:	80 91 00 3c 	lds	r24, 0x3C00	; 0x803c00 <__DATA_REGION_ORIGIN__>
     f46:	90 91 01 3c 	lds	r25, 0x3C01	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
     f4a:	a0 91 02 3c 	lds	r26, 0x3C02	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
     f4e:	b0 91 03 3c 	lds	r27, 0x3C03	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
     f52:	01 96       	adiw	r24, 0x01	; 1
     f54:	a1 1d       	adc	r26, r1
     f56:	b1 1d       	adc	r27, r1
     f58:	80 93 00 3c 	sts	0x3C00, r24	; 0x803c00 <__DATA_REGION_ORIGIN__>
     f5c:	90 93 01 3c 	sts	0x3C01, r25	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
     f60:	a0 93 02 3c 	sts	0x3C02, r26	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
     f64:	b0 93 03 3c 	sts	0x3C03, r27	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
		if(bright_mode_counter==10){
     f68:	80 91 00 3c 	lds	r24, 0x3C00	; 0x803c00 <__DATA_REGION_ORIGIN__>
     f6c:	90 91 01 3c 	lds	r25, 0x3C01	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
     f70:	a0 91 02 3c 	lds	r26, 0x3C02	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
     f74:	b0 91 03 3c 	lds	r27, 0x3C03	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
     f78:	0a 97       	sbiw	r24, 0x0a	; 10
     f7a:	a1 05       	cpc	r26, r1
     f7c:	b1 05       	cpc	r27, r1
     f7e:	41 f4       	brne	.+16     	; 0xf90 <__vector_3+0x418>
			bright_mode_counter = 0;
     f80:	10 92 00 3c 	sts	0x3C00, r1	; 0x803c00 <__DATA_REGION_ORIGIN__>
     f84:	10 92 01 3c 	sts	0x3C01, r1	; 0x803c01 <__DATA_REGION_ORIGIN__+0x1>
     f88:	10 92 02 3c 	sts	0x3C02, r1	; 0x803c02 <__DATA_REGION_ORIGIN__+0x2>
     f8c:	10 92 03 3c 	sts	0x3C03, r1	; 0x803c03 <__DATA_REGION_ORIGIN__+0x3>
		}
	}
}
     f90:	ff 91       	pop	r31
     f92:	ef 91       	pop	r30
     f94:	bf 91       	pop	r27
     f96:	af 91       	pop	r26
     f98:	9f 91       	pop	r25
     f9a:	8f 91       	pop	r24
     f9c:	7f 91       	pop	r23
     f9e:	6f 91       	pop	r22
     fa0:	5f 91       	pop	r21
     fa2:	4f 91       	pop	r20
     fa4:	3f 91       	pop	r19
     fa6:	2f 91       	pop	r18
     fa8:	0f 90       	pop	r0
     faa:	0f be       	out	0x3f, r0	; 63
     fac:	0f 90       	pop	r0
     fae:	1f 90       	pop	r1
     fb0:	18 95       	reti

00000fb2 <main>:
//Hold that value inside of the chip, maybe write it on EEPROM or ROM


int main(void)
{
	Initialize();
     fb2:	a8 dd       	rcall	.-1200   	; 0xb04 <Initialize>
     fb4:	ff cf       	rjmp	.-2      	; 0xfb4 <main+0x2>

00000fb6 <__divmodsi4>:
     fb6:	05 2e       	mov	r0, r21
     fb8:	97 fb       	bst	r25, 7
     fba:	16 f4       	brtc	.+4      	; 0xfc0 <__divmodsi4+0xa>
     fbc:	00 94       	com	r0
     fbe:	0f d0       	rcall	.+30     	; 0xfde <__negsi2>
     fc0:	57 fd       	sbrc	r21, 7
     fc2:	05 d0       	rcall	.+10     	; 0xfce <__divmodsi4_neg2>
     fc4:	1e d0       	rcall	.+60     	; 0x1002 <__udivmodsi4>
     fc6:	07 fc       	sbrc	r0, 7
     fc8:	02 d0       	rcall	.+4      	; 0xfce <__divmodsi4_neg2>
     fca:	46 f4       	brtc	.+16     	; 0xfdc <__divmodsi4_exit>
     fcc:	08 c0       	rjmp	.+16     	; 0xfde <__negsi2>

00000fce <__divmodsi4_neg2>:
     fce:	50 95       	com	r21
     fd0:	40 95       	com	r20
     fd2:	30 95       	com	r19
     fd4:	21 95       	neg	r18
     fd6:	3f 4f       	sbci	r19, 0xFF	; 255
     fd8:	4f 4f       	sbci	r20, 0xFF	; 255
     fda:	5f 4f       	sbci	r21, 0xFF	; 255

00000fdc <__divmodsi4_exit>:
     fdc:	08 95       	ret

00000fde <__negsi2>:
     fde:	90 95       	com	r25
     fe0:	80 95       	com	r24
     fe2:	70 95       	com	r23
     fe4:	61 95       	neg	r22
     fe6:	7f 4f       	sbci	r23, 0xFF	; 255
     fe8:	8f 4f       	sbci	r24, 0xFF	; 255
     fea:	9f 4f       	sbci	r25, 0xFF	; 255
     fec:	08 95       	ret

00000fee <__muluhisi3>:
     fee:	2b d0       	rcall	.+86     	; 0x1046 <__umulhisi3>
     ff0:	a5 9f       	mul	r26, r21
     ff2:	90 0d       	add	r25, r0
     ff4:	b4 9f       	mul	r27, r20
     ff6:	90 0d       	add	r25, r0
     ff8:	a4 9f       	mul	r26, r20
     ffa:	80 0d       	add	r24, r0
     ffc:	91 1d       	adc	r25, r1
     ffe:	11 24       	eor	r1, r1
    1000:	08 95       	ret

00001002 <__udivmodsi4>:
    1002:	a1 e2       	ldi	r26, 0x21	; 33
    1004:	1a 2e       	mov	r1, r26
    1006:	aa 1b       	sub	r26, r26
    1008:	bb 1b       	sub	r27, r27
    100a:	fd 01       	movw	r30, r26
    100c:	0d c0       	rjmp	.+26     	; 0x1028 <__udivmodsi4_ep>

0000100e <__udivmodsi4_loop>:
    100e:	aa 1f       	adc	r26, r26
    1010:	bb 1f       	adc	r27, r27
    1012:	ee 1f       	adc	r30, r30
    1014:	ff 1f       	adc	r31, r31
    1016:	a2 17       	cp	r26, r18
    1018:	b3 07       	cpc	r27, r19
    101a:	e4 07       	cpc	r30, r20
    101c:	f5 07       	cpc	r31, r21
    101e:	20 f0       	brcs	.+8      	; 0x1028 <__udivmodsi4_ep>
    1020:	a2 1b       	sub	r26, r18
    1022:	b3 0b       	sbc	r27, r19
    1024:	e4 0b       	sbc	r30, r20
    1026:	f5 0b       	sbc	r31, r21

00001028 <__udivmodsi4_ep>:
    1028:	66 1f       	adc	r22, r22
    102a:	77 1f       	adc	r23, r23
    102c:	88 1f       	adc	r24, r24
    102e:	99 1f       	adc	r25, r25
    1030:	1a 94       	dec	r1
    1032:	69 f7       	brne	.-38     	; 0x100e <__udivmodsi4_loop>
    1034:	60 95       	com	r22
    1036:	70 95       	com	r23
    1038:	80 95       	com	r24
    103a:	90 95       	com	r25
    103c:	9b 01       	movw	r18, r22
    103e:	ac 01       	movw	r20, r24
    1040:	bd 01       	movw	r22, r26
    1042:	cf 01       	movw	r24, r30
    1044:	08 95       	ret

00001046 <__umulhisi3>:
    1046:	a2 9f       	mul	r26, r18
    1048:	b0 01       	movw	r22, r0
    104a:	b3 9f       	mul	r27, r19
    104c:	c0 01       	movw	r24, r0
    104e:	a3 9f       	mul	r26, r19
    1050:	01 d0       	rcall	.+2      	; 0x1054 <__umulhisi3+0xe>
    1052:	b2 9f       	mul	r27, r18
    1054:	70 0d       	add	r23, r0
    1056:	81 1d       	adc	r24, r1
    1058:	11 24       	eor	r1, r1
    105a:	91 1d       	adc	r25, r1
    105c:	08 95       	ret

0000105e <_exit>:
    105e:	f8 94       	cli

00001060 <__stop_program>:
    1060:	ff cf       	rjmp	.-2      	; 0x1060 <__stop_program>
